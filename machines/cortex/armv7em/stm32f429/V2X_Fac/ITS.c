
/*
	Code automatically generated by asn1scc tool
	Edited by Sayed Badr:
	 * 1- Commenting all decleared global variables.
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt.h"
#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "ITS.h"

//const V2xFac_LongitudeType V2xFac_LongitudeType_v2XFAC_LONGITUDE_TYPE_ONE_MICRO_DEGREE_EAST = 10;
//const V2xFac_LongitudeType V2xFac_LongitudeType_v2XFAC_LONGITUDE_TYPE_ONE_MICRO_DEGREE_WEST = -10;
//const V2xFac_LongitudeType V2xFac_LongitudeType_v2XFAC_LONGITUDE_TYPE_UNAVAILABLE = 1800000001;
//const V2xFac_LatitudeType V2xFac_LatitudeType_v2XFAC_LATITUDE_TYPE_ONE_MICRO_DEGREE_NORTH = 10;
//const V2xFac_LatitudeType V2xFac_LatitudeType_v2XFAC_LATITUDE_TYPE_ONE_MICRO_DEGREE_SOUTH = -10;
//const V2xFac_LatitudeType V2xFac_LatitudeType_v2XFAC_LATITUDE_UNAVAILABLE = 900000001;
//const V2xFac_AltitudeValueType V2xFac_AltitudeValueType_v2XFAC_ALTITUDE_VALUE_TYPE_REFERNCE_ELLIPSOID_SURFACE = 0;
//const V2xFac_AltitudeValueType V2xFac_AltitudeValueType_v2XFAC_ALTITUDE_VALUE_TYPE_ONE_CENTIMETER = 1;
//const V2xFac_AltitudeValueType V2xFac_AltitudeValueType_v2XFAC_ALTITUDE_VALUE_TYPE_UNAVAILABLE = 800001;
//const V2xFac_DeltaLongitudeType V2xFac_DeltaLongitudeType_v2XFAC_DELTA_LONGITUDE_TYPE_ONE_MICRO_DEGREE_EAST = 10;
//const V2xFac_DeltaLongitudeType V2xFac_DeltaLongitudeType_v2XFAC_DELTA_LONGITUDE_TYPE_ONE_MICRO_DEGREE_WEST = -10;
//const V2xFac_DeltaLongitudeType V2xFac_DeltaLongitudeType_v2XFAC_DELTA_LONGITUDE_TYPE_UNAVAILABLE = 131072;
//const V2xFac_DeltaLatitudeType V2xFac_DeltaLatitudeType_v2XFAC_DELTA_LATITUDE_TYPE_ONE_MICRO_DEGREE_NORTH = 10;
//const V2xFac_DeltaLatitudeType V2xFac_DeltaLatitudeType_v2XFAC_DELTA_LATITUDE_TYPE_ONE_MICRO_DEGREE_SOUTH = -10;
//const V2xFac_DeltaLatitudeType V2xFac_DeltaLatitudeType_v2XFAC_DELTA_LATITUDE_TYPE_UNAVAILABLE = 131072;
//const V2xFac_DeltaAltitudeType V2xFac_DeltaAltitudeType_v2XFAC_DELTA_ALTITUDE_TYPE_ONE_CENTIMETER_UP = 1;
//const V2xFac_DeltaAltitudeType V2xFac_DeltaAltitudeType_v2XFAC_DELTA_ALTITUDE_TYPE_ONE_CENTIMETER_DOWN = -1;
//const V2xFac_DeltaAltitudeType V2xFac_DeltaAltitudeType_v2XFAC_DELTA_ALTITUDE_TYPE_UNAVAILABLE = 12800;
//const V2xFac_PathDeltaTimeType V2xFac_PathDeltaTimeType_v2XFAC_PATH_DELTA_TIME_TYPE_TEN_MILLI_SECONDS_PAST = 1;
//const V2xFac_PtActivationTypeType V2xFac_PtActivationTypeType_v2XFAC_PT_ACTIVATION_TYPE_TYPE_UNDEFINED_CODING_TYPE = 0;
//const V2xFac_PtActivationTypeType V2xFac_PtActivationTypeType_v2XFAC_PT_ACTIVATION_TYPE_TYPE_R09_16_CODING_TYPE = 1;
//const V2xFac_PtActivationTypeType V2xFac_PtActivationTypeType_v2XFAC_PT_ACTIVATION_TYPE_TYPE_VDV_50149_CODING_TYPE = 2;
//const V2xFac_SemiAxisLengthType V2xFac_SemiAxisLengthType_v2XFAC_SEMI_AXIS_LENGTH_TYPE_ONE_CENTIMETER = 1;
//const V2xFac_SemiAxisLengthType V2xFac_SemiAxisLengthType_v2XFAC_SEMI_AXIS_LENGTH_TYPE_OUT_OF_RANGE = 4094;
//const V2xFac_SemiAxisLengthType V2xFac_SemiAxisLengthType_v2XFAC_SEMI_AXIS_LENGTH_TYPE_UNAVAILABLE = 4095;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_RESERVED = 0;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_TRAFFIC_CONDITION = 1;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ACCIDENT = 2;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ROAD_WORKS = 3;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ADVERSE_WEATHER_CONDITION_ADHESION = 6;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HAZARDOUS_LOCATION_SURFACE_CONDITION = 9;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HAZARDOUS_LOCATION_OBSTACLE_ONT_THE_ROAD = 10;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD = 11;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HAZARDOUS_LOCATION_HUMAN_ON_THE_ROAD = 12;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_WRONG_WAY_DRIVING = 14;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS = 15;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION = 17;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ADVERSE_WEATHER_CONDITION_VISIBILITY = 18;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_ADVERSE_WEATHER_CONDITION_PRECIPTION = 19;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_SLOW_VEHICLE = 26;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_DANGEROUS_END_OF_QUEUE = 27;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_VEHICLE_BREAK_DOWN = 91;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_POST_CRASH = 92;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HUMAN_PROBLEM = 93;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_STATIONARY_VEHICLE = 94;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_EMERGENCY_VEHICLE_APPROACHING = 95;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_HAZARDOUS_LOCATION_DANGEROUS_CURVE = 96;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_COLLISION_RISK = 97;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_SIGNAL_VIOLATION = 98;
//const V2xFac_CauseCodeTypeType V2xFac_CauseCodeTypeType_v2XFAC_CAUSE_CODE_TYPE_TYPE_DANGEROUS_SITUATION = 99;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_INCREASED_VOLUME_OF_TRAFFIC = 1;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_SLOWLY_INCREASING = 2;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_INCREASING = 3;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_STRONGLY_INCREASING = 4;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_STATIONERY = 5;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_SLIGHTLY_DECREASING = 6;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_DECREASING = 7;
//const V2xFac_TrafficConditionSubCauseCodeType V2xFac_TrafficConditionSubCauseCodeType_v2XFAC_TRAFFIC_CONDITION_SUB_CAUSE_CODE_TYPE_TRAFFIC_JAM_STRONGLY_DECREASING = 8;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_MULTI_VEHICLE_ACCIDENT = 1;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_HEAVY_ACCIDENT = 2;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_ACCIDENT_INVOLVING_LORRY = 3;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_ACCIDENT_INVOLVING_BUS = 4;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_ACCIDENT_INVOLVING_HAZARDOUS_MATERIALS = 5;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_ACCIDENT_ON_OPPOSITE_LANE = 6;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_UNSECURED_ACCIDENT = 7;
//const V2xFac_AccidentSubCauseCodeType V2xFac_AccidentSubCauseCodeType_v2XFAC_ACCIDENT_SUB_CAUSE_CODE_TYPE_ASSISTANCE_REQUESTED = 8;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_MAJOR_ROAD_WORKS = 1;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_ROAD_MARKING_WORK = 2;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_SLOW_MOVING_ROAD_MAINTENANCE = 3;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_SHORT_TERM_STATIONARY_ROADWORKS = 4;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_STREET_CLEANING = 5;
//const V2xFac_RoadworksSubCauseCodeType V2xFac_RoadworksSubCauseCodeType_v2XFAC_ROAD_WORKS_SUB_CAUSE_CODE_TYPE_WINTER_SERVICE = 6;
//const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_v2XFAC_HUMAN_PRESENCE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_v2XFAC_HUMAN_PRESENCE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_CHILDREN_ON_ROADWAY = 1;
//const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_v2XFAC_HUMAN_PRESENCE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_CYCLIST_ON_ROADWAY = 2;
//const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_v2XFAC_HUMAN_PRESENCE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_MOTORCYCLIST_ON_ROADWAY = 3;
//const V2xFac_WrongWayDrivingSubCauseCodeType V2xFac_WrongWayDrivingSubCauseCodeType_v2XFAC_WRONGWAY_DRIVING_SUB_CAUSECODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_WrongWayDrivingSubCauseCodeType V2xFac_WrongWayDrivingSubCauseCodeType_v2XFAC_WRONGWAY_DRIVING_SUB_CAUSECODE_TYPE_WRONG_LANE = 1;
//const V2xFac_WrongWayDrivingSubCauseCodeType V2xFac_WrongWayDrivingSubCauseCodeType_v2XFAC_WRONGWAY_DRIVING_SUB_CAUSECODE_TYPE_WRONG_DIRECTION = 2;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_STRONG_WINDS = 1;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_DAMAGING_HAIL = 2;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_HURRICANE = 3;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_THUNDER_STORM = 4;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_TORNADO = 5;
//const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_EXTREME_WEATHER_CONDITION_SUB_CAUSE_CODE_TYPE_BLIZZARD = 6;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_HEAVY_FROST_ON_ROAD = 1;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_FUEL_ON_ROAD = 2;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_MUD_ON_ROAD = 3;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_SNOW_ON_ROAD = 4;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_ICE_ON_ROAD = 5;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_BLACK_ICE_ON_ROAD = 6;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_OIL_ON_ROAD = 7;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_LOOSE_CHIPPINGS = 8;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_INSTANT_BLACK_ICE = 9;
//const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_ADHESION_SUB_CAUSE_CODE_TYPE_ROADS_SALTED = 10;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_FOG = 1;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_SMOKE = 2;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_HEAVY_SNOW_FALL = 3;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_HEAVY_RAIN = 4;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_HEAVY_HAIL = 5;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_LOW_SUN_GLARE = 6;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_SAND_STORMS = 7;
//const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_VISIBILITY_SUB_CAUSE_CODE_TYPE_SWARMS_OF_INSECTS = 8;
//const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_PRECIPITATION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_PRECIPITATION_SUB_CAUSE_CODE_TYPE_HEAVY_RAIN = 1;
//const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_PRECIPITATION_SUB_CAUSE_CODE_TYPE_HEAVY_SNOW_FALL = 2;
//const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_v2XFAC_ADVERSE_WEATHER_CONDITION_PRECIPITATION_SUB_CAUSE_CODE_TYPE_SOFT_HAIL = 3;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_MAINTENANCE_VEHICLE = 1;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_VEHICLES_SLOWING_TO_LOOK_AT_ACCIDENT = 2;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_ABNORMAL_LOAD = 3;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_ABNORMAL_WIDE_LOAD = 4;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_CONVOY = 5;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_SNOW_PLOUGH = 6;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_DEICING = 7;
//const V2xFac_SlowVehicleSubCauseCodeType V2xFac_SlowVehicleSubCauseCodeType_v2XFAC_SLOW_VEHICLE_SUB_CAUSE_CODE_TYPE_SALTING_VEHICLES = 8;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_HUMAN_PROBLEM = 1;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_VEHICLE_BREAKDOWN = 2;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_POST_CRASH = 3;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_PUBLIC_TRANSPORT_STOP = 4;
//const V2xFac_StationaryVehicleSubCauseCodeType V2xFac_StationaryVehicleSubCauseCodeType_v2XFAC_STATIONARY_VEHICLE_SUB_CAUSE_CODE_TYPE_CARRYING_DANGEROUS_GOODS = 5;
//const V2xFac_HumanProblemSubCauseCodeType V2xFac_HumanProblemSubCauseCodeType_v2XFAC_HUMAN_PROBLEM_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HumanProblemSubCauseCodeType V2xFac_HumanProblemSubCauseCodeType_v2XFAC_HUMAN_PROBLEM_SUB_CAUSE_CODE_TYPE_GLYCEMIA_PROBLEM = 1;
//const V2xFac_HumanProblemSubCauseCodeType V2xFac_HumanProblemSubCauseCodeType_v2XFAC_HUMAN_PROBLEM_SUB_CAUSE_CODE_TYPE_HEART_PROBLEM = 2;
//const V2xFac_EmergencyVehicleApproachingSubCauseCodeType V2xFac_EmergencyVehicleApproachingSubCauseCodeType_v2XFAC_EMERGENCY_VEHICLE_APPROACHING_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_EmergencyVehicleApproachingSubCauseCodeType V2xFac_EmergencyVehicleApproachingSubCauseCodeType_v2XFAC_EMERGENCY_VEHICLE_APPROACHING_SUB_CAUSE_CODE_TYPE_EMERGENCY_VEHICLE_APPROACHING = 1;
//const V2xFac_EmergencyVehicleApproachingSubCauseCodeType V2xFac_EmergencyVehicleApproachingSubCauseCodeType_v2XFAC_EMERGENCY_VEHICLE_APPROACHING_SUB_CAUSE_CODE_TYPE_PRIORITIZED_VEHICLE_APPROACHING = 2;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_DANGEROUS_LEFT_TURN_CURVE = 1;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_DANGEROUS_RIGHT_TURN_CURVE = 2;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_MULTIPLE_CURVES_STARTING_WITH_UNKNOWN_TURNING_DIRECTION = 3;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_MULTIPLE_CURVES_STARTING_WITH_LEFT_TURN = 4;
//const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_DANGEROUS_CURVE_SUB_CAUSE_CODE_TYPE_MULTIPLE_CURVES_STARTING_WITH_RIGHT_TURN = 5;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_ROCKFALLS = 1;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_EARTHQUAKE_DAMAGE = 2;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_SEWER_COLLAPSE = 3;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_SUBSIDENCE = 4;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_SNOW_DRIFTS = 5;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_STORM_DAMAGE = 6;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_BURST_PIPE = 7;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_VOLCANO_ERUPTION = 8;
//const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_SURFACE_CONDITION_SUB_CAUSE_CODE_TYPE_FALLING_ICE = 9;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_SHED_LOAD = 1;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_PARTS_OF_VEHICLES = 2;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_PARTS_OF_TYRES = 3;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_BIG_OBJECTS = 4;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_FALLEN_TREES = 5;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_HUB_CAPS = 6;
//const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_OBSTACLE_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_WAITING_VEHICLES = 7;
//const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_WILD_ANIMALS = 1;
//const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_HERD_OF_ANIMALS = 2;
//const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_SMALL_ANIMALS = 3;
//const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_v2XFAC_HAZARDOUS_LOCATION_ANIMAL_ON_THE_ROAD_SUB_CAUSE_CODE_TYPE_LARGE_ANIMALS = 4;
//const V2xFac_CollisionRiskSubCauseCodeType V2xFac_CollisionRiskSubCauseCodeType_v2XFAC_COLLISION_RISK_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_CollisionRiskSubCauseCodeType V2xFac_CollisionRiskSubCauseCodeType_v2XFAC_COLLISION_RISK_SUB_CAUSE_CODE_TYPE_LONGITUDINAL_COLLISION_RISK = 1;
//const V2xFac_CollisionRiskSubCauseCodeType V2xFac_CollisionRiskSubCauseCodeType_v2XFAC_COLLISION_RISK_SUB_CAUSE_CODE_TYPE_CROSSING_COLLISION_RISK = 2;
//const V2xFac_CollisionRiskSubCauseCodeType V2xFac_CollisionRiskSubCauseCodeType_v2XFAC_COLLISION_RISK_SUB_CAUSE_CODE_TYPE_LATERAL_COLLISION_RISK = 3;
//const V2xFac_CollisionRiskSubCauseCodeType V2xFac_CollisionRiskSubCauseCodeType_v2XFAC_COLLISION_RISK_SUB_CAUSE_CODE_TYPE_VULNERABLE_ROAD_USER = 4;
//const V2xFac_SignalViolationSubCauseCodeType V2xFac_SignalViolationSubCauseCodeType_v2XFAC_SIGNAL_VIOLATION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_SignalViolationSubCauseCodeType V2xFac_SignalViolationSubCauseCodeType_v2XFAC_SIGNAL_VIOLATION_SUB_CAUSE_CODE_TYPE_STOP_SIGN_VIOLATION = 1;
//const V2xFac_SignalViolationSubCauseCodeType V2xFac_SignalViolationSubCauseCodeType_v2XFAC_SIGNAL_VIOLATION_SUB_CAUSE_CODE_TYPE_TRAFFIC_LIGHT_VIOLATION = 2;
//const V2xFac_SignalViolationSubCauseCodeType V2xFac_SignalViolationSubCauseCodeType_v2XFAC_SIGNAL_VIOLATION_SUB_CAUSE_CODE_TYPE_TURNING_REGULATION_VIOLATION = 3;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_EMERGENCY_VEHICLES = 1;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_RESCUE_HELICOPTER_LANDING = 2;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_POLICE_ACTIVITY_ONGOING = 3;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_MEDICAL_EMERGENCY_ONGOING = 4;
//const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_v2XFAC_RESCUE_AND_RECOVERY_WORK_IN_PROGRESS_SUB_CAUSE_CODE_TYPE_CHILD_ABDUCTION_IN_PROGRESS = 5;
//const V2xFac_DangerousEndOfQueueSubCauseCodeType V2xFac_DangerousEndOfQueueSubCauseCodeType_v2XFAC_DANGEROUS_END_OF_QUEUE_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_DangerousEndOfQueueSubCauseCodeType V2xFac_DangerousEndOfQueueSubCauseCodeType_v2XFAC_DANGEROUS_END_OF_QUEUE_SUB_CAUSE_CODE_TYPE_SUDDEN_END_OF_QUEUE = 1;
//const V2xFac_DangerousEndOfQueueSubCauseCodeType V2xFac_DangerousEndOfQueueSubCauseCodeType_v2XFAC_DANGEROUS_END_OF_QUEUE_SUB_CAUSE_CODE_TYPE_QUEUE_OVER_HILL = 2;
//const V2xFac_DangerousEndOfQueueSubCauseCodeType V2xFac_DangerousEndOfQueueSubCauseCodeType_v2XFAC_DANGEROUS_END_OF_QUEUE_SUB_CAUSE_CODE_TYPE_QUEUE_AROUND_BEND = 3;
//const V2xFac_DangerousEndOfQueueSubCauseCodeType V2xFac_DangerousEndOfQueueSubCauseCodeType_v2XFAC_DANGEROUS_END_OF_QUEUE_SUB_CAUSE_CODE_TYPE_QUEUE_IN_TUNNEL = 4;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_EMERGENCY_ELECTRONIC_BRAKE_ENGAGED = 1;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_PRE_CRASH_SYSTEM_ENGAGED = 2;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_ESP_ENGAGED = 3;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_ABS_ENGAGED = 4;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_AEB_ENGAGED = 5;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_BRAKE_WARNING_ENGAGED = 6;
//const V2xFac_DangerousSituationSubCauseCodeType V2xFac_DangerousSituationSubCauseCodeType_v2XFAC_DANGEROUS_SITUATION_SUB_CAUSE_CODE_TYPE_COLLISION_RISK_WARNING_ENGAGED = 7;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_LACK_OF_FUEL = 1;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_LACK_OF_BATTERY_POWER = 2;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_ENGINE_PROBLEM = 3;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_TRANSMISSION_PROBLEM = 4;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_ENGINE_COOLING_PROBLEM = 5;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_BRAKING_SYSTEM_PROBLEM = 6;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_STEERING_PROBLEM = 7;
//const V2xFac_VehicleBreakdownSubCauseCodeType V2xFac_VehicleBreakdownSubCauseCodeType_v2XFAC_VEHICLE_BREAK_DOWN_SUB_CAUSE_CODE_TYPE_TYRE_PUNCTURE = 8;
//const V2xFac_PostCrashSubCauseCodeType V2xFac_PostCrashSubCauseCodeType_v2XFAC_POST_CRASH_SUB_CAUSE_CODE_TYPE_UNAVAILABLE = 0;
//const V2xFac_PostCrashSubCauseCodeType V2xFac_PostCrashSubCauseCodeType_v2XFAC_POST_CRASH_SUB_CAUSE_CODE_TYPE_ACCIDENT_WITHOUT_E_CALL_TRIGGERED = 1;
//const V2xFac_PostCrashSubCauseCodeType V2xFac_PostCrashSubCauseCodeType_v2XFAC_POST_CRASH_SUB_CAUSE_CODE_TYPE_ACCIDENT_WITH_E_CALL_MANUALLY_TRIGGERED = 2;
//const V2xFac_PostCrashSubCauseCodeType V2xFac_PostCrashSubCauseCodeType_v2XFAC_POST_CRASH_SUB_CAUSE_CODE_TYPE_ACCIDENT_WITH_E_CALL_AUTOMATICALLY_TRIGGERED = 3;
//const V2xFac_PostCrashSubCauseCodeType V2xFac_PostCrashSubCauseCodeType_v2XFAC_POST_CRASH_SUB_CAUSE_CODE_TYPE_ACCIDENT_WITH_E_CALL_TRIGGER_ED_WITHOUT_ACCESS_TO_CELLULAR_NETWORK = 4;
//const V2xFac_CurvatureValueType V2xFac_CurvatureValueType_v2XFAC_CURVATURE_VALUE_TYPE_STRAIGHT = 0;
//const V2xFac_CurvatureValueType V2xFac_CurvatureValueType_v2XFAC_CURVATURE_VALUE_TYPE_RECIPROCAL_OF_1_METER_RADIUS_TO_RIGHT = -30000;
//const V2xFac_CurvatureValueType V2xFac_CurvatureValueType_v2XFAC_CURVATURE_VALUE_TYPE_RECIPROCAL_OF_1_METER_RADIUS_TO_LEFT = 30000;
//const V2xFac_CurvatureValueType V2xFac_CurvatureValueType_v2XFAC_CURVATURE_VALUE_TYPE_UNAVAILABLE = 30001;
//const V2xFac_HeadingValueType V2xFac_HeadingValueType_v2XFAC_HEADING_VALUE_TYPE_WGS_84_NORTH = 0;
//const V2xFac_HeadingValueType V2xFac_HeadingValueType_v2XFAC_HEADING_VALUE_TYPE_WGS_84_EAST = 900;
//const V2xFac_HeadingValueType V2xFac_HeadingValueType_v2XFAC_HEADING_VALUE_TYPE_WGS_84_SOUTH = 1800;
//const V2xFac_HeadingValueType V2xFac_HeadingValueType_v2XFAC_HEADING_VALUE_TYPE_WGS_84_WEST = 2700;
//const V2xFac_HeadingValueType V2xFac_HeadingValueType_v2XFAC_HEADING_VALUE_TYPE_UNAVAILABLE = 3601;
//const V2xFac_HeadingConfidenceType V2xFac_HeadingConfidenceType_v2XFAC_HEADING_CONFIDENCE_TYPE_EQUAL_OR_WITHIN_ZERO_POINT_ONE_DEGREE = 1;
//const V2xFac_HeadingConfidenceType V2xFac_HeadingConfidenceType_v2XFAC_HEADING_CONFIDENCE_TYPE_EQUAL_OR_WITHIN_ONE_DEGREE = 10;
//const V2xFac_HeadingConfidenceType V2xFac_HeadingConfidenceType_v2XFAC_HEADING_CONFIDENCE_TYPE_OUT_OF_RANGE = 126;
//const V2xFac_HeadingConfidenceType V2xFac_HeadingConfidenceType_v2XFAC_HEADING_CONFIDENCE_TYPE_UNAVAILABLE = 127;
//const V2xFac_LanePositionType V2xFac_LanePositionType_v2XFAC_LANE_POSITION_TYPE_OFF_THE_ROAD = -1;
//const V2xFac_LanePositionType V2xFac_LanePositionType_v2XFAC_LANE_POSITION_TYPE_HARD_SHOULDER = 0;
//const V2xFac_LanePositionType V2xFac_LanePositionType_v2XFAC_LANE_POSITION_TYPE_OUTER_MOST_DRIVING_LANE = 1;
//const V2xFac_LanePositionType V2xFac_LanePositionType_v2XFAC_LANE_POSITION_TYPE_SECOND_LANE_FROM_OUTSIDE = 2;
//const V2xFac_PerformanceClassType V2xFac_PerformanceClassType_v2XFAC_PERFORMANCE_CLASS_TYPE_UNAVAILABLE = 0;
//const V2xFac_PerformanceClassType V2xFac_PerformanceClassType_v2XFAC_PERFORMANCE_CLASS_TYPE_PERFORMANCE_CLASS_A = 1;
//const V2xFac_PerformanceClassType V2xFac_PerformanceClassType_v2XFAC_PERFORMANCE_CLASS_TYPE_PERFORMANCE_CLASS_B = 2;
//const V2xFac_SpeedValueType V2xFac_SpeedValueType_v2XFAC_SPEED_VALUE_TYPE_STANDSTILL = 0;
//const V2xFac_SpeedValueType V2xFac_SpeedValueType_v2XFAC_SPEED_VALUE_TYPE_ONE_CENTIMETER_PER_SEC = 1;
//const V2xFac_SpeedValueType V2xFac_SpeedValueType_v2XFAC_SPEED_VALUE_TYPE_UNAVAILABLE = 16383;
//const V2xFac_SpeedConfidenceType V2xFac_SpeedConfidenceType_v2XFAC_SPEED_CONFIDENCE_TYPE_EQUAL_OR_WITHIN_ONE_CENTIMETER_PER_SEC = 1;
//const V2xFac_SpeedConfidenceType V2xFac_SpeedConfidenceType_v2XFAC_SPEED_CONFIDENCE_TYPE_EQUAL_OR_WITHIN_ONE_METER_PER_SEC = 100;
//const V2xFac_SpeedConfidenceType V2xFac_SpeedConfidenceType_v2XFAC_SPEED_CONFIDENCE_TYPE_OUT_OF_RANGE = 126;
//const V2xFac_SpeedConfidenceType V2xFac_SpeedConfidenceType_v2XFAC_SPEED_CONFIDENCE_TYPE_UNAVAILABLE = 127;
//const V2xFac_VehicleMassType V2xFac_VehicleMassType_v2XFAC_VEHICLE_MASS_TYPE_HUNDRED_KG = 1;
//const V2xFac_VehicleMassType V2xFac_VehicleMassType_v2XFAC_VEHICLE_MASS_TYPE_UNAVAILABLE = 1024;
//const V2xFac_LongitudinalAccelerationValueType V2xFac_LongitudinalAccelerationValueType_v2XFAC_LONGITUDINAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_FORWARD = 1;
//const V2xFac_LongitudinalAccelerationValueType V2xFac_LongitudinalAccelerationValueType_v2XFAC_LONGITUDINAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_BACKWARD = -1;
//const V2xFac_LongitudinalAccelerationValueType V2xFac_LongitudinalAccelerationValueType_v2XFAC_LONGITUDINAL_ACCELERATION_VALUE_TYPE_UNAVAILABLE = 161;
//const V2xFac_AccelerationConfidenceType V2xFac_AccelerationConfidenceType_v2XFAC_ACCELERATION_CONFIDENCE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED = 1;
//const V2xFac_AccelerationConfidenceType V2xFac_AccelerationConfidenceType_v2XFAC_ACCELERATION_CONFIDENCE_TYPE_OUT_OF_RANGE = 101;
//const V2xFac_AccelerationConfidenceType V2xFac_AccelerationConfidenceType_v2XFAC_ACCELERATION_CONFIDENCE_TYPE_UNAVAILABLE = 102;
//const V2xFac_LateralAccelerationValueType V2xFac_LateralAccelerationValueType_v2XFAC_LATERAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_TO_RIGHT = -1;
//const V2xFac_LateralAccelerationValueType V2xFac_LateralAccelerationValueType_v2XFAC_LATERAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_TO_LEFT = 1;
//const V2xFac_LateralAccelerationValueType V2xFac_LateralAccelerationValueType_v2XFAC_LATERAL_ACCELERATION_VALUE_TYPE_UNAVAILABLE = 161;
//const V2xFac_VerticalAccelerationValueType V2xFac_VerticalAccelerationValueType_v2XFAC_VERTICAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_UP = 1;
//const V2xFac_VerticalAccelerationValueType V2xFac_VerticalAccelerationValueType_v2XFAC_VERTICAL_ACCELERATION_VALUE_TYPE_POINT_ONE_METER_PER_SEC_SQUARED_DOWN = -1;
//const V2xFac_VerticalAccelerationValueType V2xFac_VerticalAccelerationValueType_v2XFAC_VERTICAL_ACCELERATION_VALUE_TYPE_UNAVAILABLE = 161;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_UNKNOWN = 0;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_PEDESTRIAN = 1;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_CYCLIST = 2;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_MOPED = 3;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_MOTORCYCLE = 4;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_PASSENGERCAR = 5;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_BUS = 6;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_LIGHTTRUCK = 7;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_HEAVYTRUCK = 8;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_TRAILER = 9;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_SPECIALVEHICLES = 10;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_TRAM = 11;
//const V2xFac_StationTypeType V2xFac_StationTypeType_v2XFAC_ST_ROADSIDEUNIT = 15;
//const V2xFac_HeightLonCarrType V2xFac_HeightLonCarrType_v2XFAC_HEIGHT_LON_CAR_R_TYPE_ONE_CENTIMETER = 1;
//const V2xFac_HeightLonCarrType V2xFac_HeightLonCarrType_v2XFAC_HEIGHT_LON_CAR_R_TYPE_UNAVAILABLE = 100;
//const V2xFac_PosLonCarrType V2xFac_PosLonCarrType_v2XFAC_POS_LON_CAR_R_TYPE_ONE_CENTIMETER = 1;
//const V2xFac_PosLonCarrType V2xFac_PosLonCarrType_v2XFAC_POS_LON_CAR_R_TYPE_UNAVAILABLE = 127;
//const V2xFac_PosPillarType V2xFac_PosPillarType_v2XFAC_POS_PILLAR_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_PosPillarType V2xFac_PosPillarType_v2XFAC_POS_PILLAR_TYPE_UNAVAILABLE = 30;
//const V2xFac_PosCentMassType V2xFac_PosCentMassType_v2XFAC_POS_CENT_MASS_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_PosCentMassType V2xFac_PosCentMassType_v2XFAC_POS_CENT_MASS_TYPE_UNAVAILABLE = 63;
//const V2xFac_SpeedLimitType V2xFac_SpeedLimitType_v2XFAC_SPEED_LIMIT_TYPE_ONE_KM_PER_HOUR = 1;
//const V2xFac_TemperatureType V2xFac_TemperatureType_v2XFAC_TEMPERATURE_TYPE_EQUAL_OR_SMALLER_THAN_MINUS_60DEG = -60;
//const V2xFac_TemperatureType V2xFac_TemperatureType_v2XFAC_TEMPERATURE_TYPE_ONE_DEGREE_CELSIUS = 1;
//const V2xFac_TemperatureType V2xFac_TemperatureType_v2XFAC_TEMPERATURE_TYPE_EQUAL_OR_GREATER_THAN_67DEG = 67;
//const V2xFac_WheelBaseVehicleType V2xFac_WheelBaseVehicleType_v2XFAC_WHEEL_BASE_VEHICLE_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_WheelBaseVehicleType V2xFac_WheelBaseVehicleType_v2XFAC_WHEEL_BASE_VEHICLE_TYPE_UNAVAILABLE = 127;
//const V2xFac_TurningRadiusType V2xFac_TurningRadiusType_v2XFAC_TURNING_RADIUS_TYPE_POINT_4_METERS = 1;
//const V2xFac_TurningRadiusType V2xFac_TurningRadiusType_v2XFAC_TURNING_RADIUS_TYPE_UNAVAILABLE = 255;
//const V2xFac_PosFrontAxType V2xFac_PosFrontAxType_v2XFAC_POS_FRONT_AX_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_PosFrontAxType V2xFac_PosFrontAxType_v2XFAC_POS_FRONT_AX_TYPE_UNAVAILABLE = 20;
//const V2xFac_VehicleLengthValueType V2xFac_VehicleLengthValueType_v2XFAC_VEHICLE_LENGTH_VALUE_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_VehicleLengthValueType V2xFac_VehicleLengthValueType_v2XFAC_VEHICLE_LENGTH_VALUE_TYPE_OUT_OF_RANGE = 1022;
//const V2xFac_VehicleLengthValueType V2xFac_VehicleLengthValueType_v2XFAC_VEHICLE_LENGTH_VALUE_TYPE_UNAVAILABLE = 1023;
//const V2xFac_VehicleWidthType V2xFac_VehicleWidthType_v2XFAC_VEHICLE_WIDTH_TYPE_TEN_CENTIMETERS = 1;
//const V2xFac_VehicleWidthType V2xFac_VehicleWidthType_v2XFAC_VEHICLE_WIDTH_TYPE_OUT_OF_RANGE = 61;
//const V2xFac_VehicleWidthType V2xFac_VehicleWidthType_v2XFAC_VEHICLE_WIDTH_TYPE_UNAVAILABLE = 62;
//const V2xFac_InformationQualityType V2xFac_InformationQualityType_v2XFAC_INFORMATION_QUALITY_TYPE_UNAVAILABLE = 0;
//const V2xFac_InformationQualityType V2xFac_InformationQualityType_v2XFAC_INFORMATION_QUALITY_TYPE_LOWEST = 1;
//const V2xFac_InformationQualityType V2xFac_InformationQualityType_v2XFAC_INFORMATION_QUALITY_TYPE_HIGHEST = 7;
//const V2xFac_SteeringWheelAngleValueType V2xFac_SteeringWheelAngleValueType_v2XFAC_STEERING_WHEEL_ANGLE_VALUE_TYPE_STRAIGHT = 0;
//const V2xFac_SteeringWheelAngleValueType V2xFac_SteeringWheelAngleValueType_v2XFAC_STEERING_WHEEL_ANGLE_VALUE_TYPE_ONE_POINT_FIVE_DEGREES_TO_RIGHT = -1;
//const V2xFac_SteeringWheelAngleValueType V2xFac_SteeringWheelAngleValueType_v2XFAC_STEERING_WHEEL_ANGLE_VALUE_TYPE_ONE_POINT_FIVE_DEGREES_TO_LEFT = 1;
//const V2xFac_SteeringWheelAngleValueType V2xFac_SteeringWheelAngleValueType_v2XFAC_STEERING_WHEEL_ANGLE_VALUE_TYPE_UNAVAILABLE = 512;
//const V2xFac_SteeringWheelAngleConfidenceType V2xFac_SteeringWheelAngleConfidenceType_v2XFAC_STEERING_WHEEL_ANGLE_CONFIDENCE_TYPE_EQUAL_OR_WITH_IN_ONE_POINT_FIVE_DEGREE = 1;
//const V2xFac_SteeringWheelAngleConfidenceType V2xFac_SteeringWheelAngleConfidenceType_v2XFAC_STEERING_WHEEL_ANGLE_CONFIDENCE_TYPE_OUT_OF_RANGE = 126;
//const V2xFac_SteeringWheelAngleConfidenceType V2xFac_SteeringWheelAngleConfidenceType_v2XFAC_STEERING_WHEEL_ANGLE_CONFIDENCE_TYPE_UNAVAILABLE = 127;
//const V2xFac_TimestampItsType V2xFac_TimestampItsType_v2XFAC_TIME_STAMP_ITS_TYPE_UTC_START_OF_2004 = 0;
//const V2xFac_TimestampItsType V2xFac_TimestampItsType_v2XFAC_TIME_STAMP_ITS_TYPE_ONE_MILLI_SEC_AFTER_UTC_START_OF_2004 = 1;
//const V2xFac_YawRateValueType V2xFac_YawRateValueType_v2XFAC_YAWRATE_VALUE_TYPE_STRAIGHT = 0;
//const V2xFac_YawRateValueType V2xFac_YawRateValueType_v2XFAC_YAWRATE_VALUE_TYPE_DEGSEC_000_01_TO_RIGHT = -1;
//const V2xFac_YawRateValueType V2xFac_YawRateValueType_v2XFAC_YAWRATE_VALUE_TYPE_DEGSEC_000_01_TO_LEFT = 1;
//const V2xFac_YawRateValueType V2xFac_YawRateValueType_v2XFAC_YAWRATE_VALUE_TYPE_UNAVAILABLE = 32767;
//const V2xFac_TransmissionIntervalType V2xFac_TransmissionIntervalType_v2XFAC_TRANSMISSION_INTERVAL_TYPE_one_Milli_Second = 1;
//const V2xFac_TransmissionIntervalType V2xFac_TransmissionIntervalType_v2XFAC_TRANSMISSION_INTERVAL_TYPE_ten_Seconds = 10000;
//const V2xFac_ValidityDurationType V2xFac_ValidityDurationType_v2XFAC_VALIDITY_DURATION_TYPE_TIME_OF_DETECTION = 0;
//const V2xFac_ValidityDurationType V2xFac_ValidityDurationType_v2XFAC_VALIDITY_DURATION_TYPE_ONE_SECOND_AFTER_DETECTION = 1;
//const V2xFac_NumberOfOccupantsType V2xFac_NumberOfOccupantsType_v2XFAC_NUMBER_OF_OCCUPANTS_TYPE_ONE_OCCUPANT = 1;
//const V2xFac_NumberOfOccupantsType V2xFac_NumberOfOccupantsType_v2XFAC_NUMBER_OF_OCCUPANTS_TYPE_UNAVAILABLE = 127;
//const V2xFac_ProtectedZoneRadiusType V2xFac_ProtectedZoneRadiusType_v2XFAC_PROTECTED_ZONE_RADIUS_TYPE_ONE_METER = 1;


void V2xFac_StationIDType_Initialize(V2xFac_StationIDType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_StationIDType_IsConstraintValid(const V2xFac_StationIDType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STATIONIDTYPE; 

	return ret;
}

flag V2xFac_StationIDType_Encode(const V2xFac_StationIDType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_StationIDType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_StationIDType_Decode(V2xFac_StationIDType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONIDTYPE;

	return ret  && V2xFac_StationIDType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ItsPduHeaderType_protocolVersion_Initialize(V2xFac_ItsPduHeaderType_protocolVersion* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void V2xFac_ItsPduHeaderType_messageId_Initialize(V2xFac_ItsPduHeaderType_messageId* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void V2xFac_ItsPduHeaderType_Initialize(V2xFac_ItsPduHeaderType* pVal)
{
	(void)pVal;



	/*set protocolVersion */
	V2xFac_ItsPduHeaderType_protocolVersion_Initialize((&(pVal->protocolVersion)));
	/*set messageId */
	V2xFac_ItsPduHeaderType_messageId_Initialize((&(pVal->messageId)));
	/*set stationId */
	V2xFac_StationIDType_Initialize((&(pVal->stationId)));
}

flag V2xFac_ItsPduHeaderType_IsConstraintValid(const V2xFac_ItsPduHeaderType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->protocolVersion <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ITSPDUHEADERTYPE_PROTOCOLVERSION; 
    if (ret) {
        ret = (pVal->messageId <= 255UL);
        *pErrCode = ret ? 0 :  ERR_V2XFAC_ITSPDUHEADERTYPE_MESSAGEID; 
        if (ret) {
            ret = V2xFac_StationIDType_IsConstraintValid((&(pVal->stationId)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_ItsPduHeaderType_Encode(const V2xFac_ItsPduHeaderType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ItsPduHeaderType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode protocolVersion */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->protocolVersion, 0, 255);
	    if (ret) {
	        /*Encode messageId */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->messageId, 0, 255);
	        if (ret) {
	            /*Encode stationId */
	            ret = V2xFac_StationIDType_Encode((&(pVal->stationId)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ItsPduHeaderType_Decode(V2xFac_ItsPduHeaderType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode protocolVersion */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->protocolVersion)), 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ITSPDUHEADERTYPE_PROTOCOLVERSION;
	if (ret) {
	    /*Decode messageId */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->messageId)), 0, 255);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ITSPDUHEADERTYPE_MESSAGEID;
	    if (ret) {
	        /*Decode stationId */
	        ret = V2xFac_StationIDType_Decode((&(pVal->stationId)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_ItsPduHeaderType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LongitudeType_Initialize(V2xFac_LongitudeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_LongitudeType_IsConstraintValid(const V2xFac_LongitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1800000000LL <= (*(pVal))) && ((*(pVal)) <= 1800000001LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_LONGITUDETYPE; 

	return ret;
}

flag V2xFac_LongitudeType_Encode(const V2xFac_LongitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LongitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -1800000000, 1800000001);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LongitudeType_Decode(V2xFac_LongitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -1800000000, 1800000001);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LONGITUDETYPE;

	return ret  && V2xFac_LongitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LatitudeType_Initialize(V2xFac_LatitudeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_LatitudeType_IsConstraintValid(const V2xFac_LatitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-900000000LL <= (*(pVal))) && ((*(pVal)) <= 900000001LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_LATITUDETYPE; 

	return ret;
}

flag V2xFac_LatitudeType_Encode(const V2xFac_LatitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LatitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -900000000, 900000001);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LatitudeType_Decode(V2xFac_LatitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -900000000, 900000001);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LATITUDETYPE;

	return ret  && V2xFac_LatitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AltitudeValueType_Initialize(V2xFac_AltitudeValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AltitudeValueType_IsConstraintValid(const V2xFac_AltitudeValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-100000LL <= (*(pVal))) && ((*(pVal)) <= 800001LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ALTITUDEVALUETYPE; 

	return ret;
}

flag V2xFac_AltitudeValueType_Encode(const V2xFac_AltitudeValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AltitudeValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -100000, 800001);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AltitudeValueType_Decode(V2xFac_AltitudeValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -100000, 800001);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALTITUDEVALUETYPE;

	return ret  && V2xFac_AltitudeValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AltitudeConfidenceType_Initialize(V2xFac_AltitudeConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_01;
}

flag V2xFac_AltitudeConfidenceType_IsConstraintValid(const V2xFac_AltitudeConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_01)) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_02)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_05)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_10)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_20)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_000_50)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_001_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_002_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_005_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_010_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_020_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_050_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_100_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_200_00)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_OUTOFRANGE)))) || (((*(pVal)) == v2XFAC_ALTITUDECONFIDENCE_ALT_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ALTITUDECONFIDENCETYPE; 

	return ret;
}

flag V2xFac_AltitudeConfidenceType_Encode(const V2xFac_AltitudeConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AltitudeConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_01:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_02:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_05:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_10:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_20:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_000_50:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_001_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_002_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_005_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_010_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_020_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_050_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_100_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_200_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_OUTOFRANGE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
	        	break;
	        case v2XFAC_ALTITUDECONFIDENCE_ALT_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_ALTITUDECONFIDENCETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AltitudeConfidenceType_Decode(V2xFac_AltitudeConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALTITUDECONFIDENCETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_01;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_02;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_05;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_10;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_20;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_50;
	                break;
	            case 6: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_001_00;
	                break;
	            case 7: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_002_00;
	                break;
	            case 8: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_005_00;
	                break;
	            case 9: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_010_00;
	                break;
	            case 10: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_020_00;
	                break;
	            case 11: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_050_00;
	                break;
	            case 12: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_100_00;
	                break;
	            case 13: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_200_00;
	                break;
	            case 14: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_OUTOFRANGE;
	                break;
	            case 15: 
	                (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_ALTITUDECONFIDENCETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_ALTITUDECONFIDENCE_ALT_000_01;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_AltitudeConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AltitudeType_Initialize(V2xFac_AltitudeType* pVal)
{
	(void)pVal;



	/*set altitudeValue */
	V2xFac_AltitudeValueType_Initialize((&(pVal->altitudeValue)));
	/*set altitudeConfidence */
	V2xFac_AltitudeConfidenceType_Initialize((&(pVal->altitudeConfidence)));
}

flag V2xFac_AltitudeType_IsConstraintValid(const V2xFac_AltitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_AltitudeValueType_IsConstraintValid((&(pVal->altitudeValue)), pErrCode);
    if (ret) {
        ret = V2xFac_AltitudeConfidenceType_IsConstraintValid((&(pVal->altitudeConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_AltitudeType_Encode(const V2xFac_AltitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AltitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode altitudeValue */
	    ret = V2xFac_AltitudeValueType_Encode((&(pVal->altitudeValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode altitudeConfidence */
	        ret = V2xFac_AltitudeConfidenceType_Encode((&(pVal->altitudeConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AltitudeType_Decode(V2xFac_AltitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode altitudeValue */
	ret = V2xFac_AltitudeValueType_Decode((&(pVal->altitudeValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode altitudeConfidence */
	    ret = V2xFac_AltitudeConfidenceType_Decode((&(pVal->altitudeConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_AltitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DeltaLongitudeType_Initialize(V2xFac_DeltaLongitudeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_DeltaLongitudeType_IsConstraintValid(const V2xFac_DeltaLongitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-131071LL <= (*(pVal))) && ((*(pVal)) <= 131072LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DELTALONGITUDETYPE; 

	return ret;
}

flag V2xFac_DeltaLongitudeType_Encode(const V2xFac_DeltaLongitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DeltaLongitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -131071, 131072);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DeltaLongitudeType_Decode(V2xFac_DeltaLongitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -131071, 131072);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DELTALONGITUDETYPE;

	return ret  && V2xFac_DeltaLongitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DeltaLatitudeType_Initialize(V2xFac_DeltaLatitudeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_DeltaLatitudeType_IsConstraintValid(const V2xFac_DeltaLatitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-131071LL <= (*(pVal))) && ((*(pVal)) <= 131072LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DELTALATITUDETYPE; 

	return ret;
}

flag V2xFac_DeltaLatitudeType_Encode(const V2xFac_DeltaLatitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DeltaLatitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -131071, 131072);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DeltaLatitudeType_Decode(V2xFac_DeltaLatitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -131071, 131072);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DELTALATITUDETYPE;

	return ret  && V2xFac_DeltaLatitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DeltaAltitudeType_Initialize(V2xFac_DeltaAltitudeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_DeltaAltitudeType_IsConstraintValid(const V2xFac_DeltaAltitudeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-12700LL <= (*(pVal))) && ((*(pVal)) <= 12800LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DELTAALTITUDETYPE; 

	return ret;
}

flag V2xFac_DeltaAltitudeType_Encode(const V2xFac_DeltaAltitudeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DeltaAltitudeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -12700, 12800);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DeltaAltitudeType_Decode(V2xFac_DeltaAltitudeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -12700, 12800);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DELTAALTITUDETYPE;

	return ret  && V2xFac_DeltaAltitudeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DeltaReferencePositionType_Initialize(V2xFac_DeltaReferencePositionType* pVal)
{
	(void)pVal;



	/*set deltaLatitude */
	V2xFac_DeltaLatitudeType_Initialize((&(pVal->deltaLatitude)));
	/*set deltaLongitude */
	V2xFac_DeltaLongitudeType_Initialize((&(pVal->deltaLongitude)));
	/*set deltaAltitude */
	V2xFac_DeltaAltitudeType_Initialize((&(pVal->deltaAltitude)));
}

flag V2xFac_DeltaReferencePositionType_IsConstraintValid(const V2xFac_DeltaReferencePositionType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_DeltaLatitudeType_IsConstraintValid((&(pVal->deltaLatitude)), pErrCode);
    if (ret) {
        ret = V2xFac_DeltaLongitudeType_IsConstraintValid((&(pVal->deltaLongitude)), pErrCode);
        if (ret) {
            ret = V2xFac_DeltaAltitudeType_IsConstraintValid((&(pVal->deltaAltitude)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_DeltaReferencePositionType_Encode(const V2xFac_DeltaReferencePositionType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DeltaReferencePositionType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode deltaLatitude */
	    ret = V2xFac_DeltaLatitudeType_Encode((&(pVal->deltaLatitude)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode deltaLongitude */
	        ret = V2xFac_DeltaLongitudeType_Encode((&(pVal->deltaLongitude)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode deltaAltitude */
	            ret = V2xFac_DeltaAltitudeType_Encode((&(pVal->deltaAltitude)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DeltaReferencePositionType_Decode(V2xFac_DeltaReferencePositionType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode deltaLatitude */
	ret = V2xFac_DeltaLatitudeType_Decode((&(pVal->deltaLatitude)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode deltaLongitude */
	    ret = V2xFac_DeltaLongitudeType_Decode((&(pVal->deltaLongitude)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode deltaAltitude */
	        ret = V2xFac_DeltaAltitudeType_Decode((&(pVal->deltaAltitude)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_DeltaReferencePositionType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PathDeltaTimeType_Initialize(V2xFac_PathDeltaTimeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_PathDeltaTimeType_IsConstraintValid(const V2xFac_PathDeltaTimeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 65535UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PATHDELTATIMETYPE; 

	return ret;
}

flag V2xFac_PathDeltaTimeType_Encode(const V2xFac_PathDeltaTimeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PathDeltaTimeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PathDeltaTimeType_Decode(V2xFac_PathDeltaTimeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PATHDELTATIMETYPE;

	return ret  && V2xFac_PathDeltaTimeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PathPointType_Initialize(V2xFac_PathPointType* pVal)
{
	(void)pVal;



	/*set pathPosition */
	V2xFac_DeltaReferencePositionType_Initialize((&(pVal->pathPosition)));
	/*set pathDeltaTime */
	pVal->exist.pathDeltaTime = 1;
	V2xFac_PathDeltaTimeType_Initialize((&(pVal->pathDeltaTime)));
}

flag V2xFac_PathPointType_IsConstraintValid(const V2xFac_PathPointType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_DeltaReferencePositionType_IsConstraintValid((&(pVal->pathPosition)), pErrCode);
    if (ret) {
        if (pVal->exist.pathDeltaTime) {
        	ret = V2xFac_PathDeltaTimeType_IsConstraintValid((&(pVal->pathDeltaTime)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_PathPointType_Encode(const V2xFac_PathPointType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PathPointType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.pathDeltaTime);
	    if (ret) {
	        /*Encode pathPosition */
	        ret = V2xFac_DeltaReferencePositionType_Encode((&(pVal->pathPosition)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode pathDeltaTime */
	            if (pVal->exist.pathDeltaTime) {
	            	ret = V2xFac_PathDeltaTimeType_Encode((&(pVal->pathDeltaTime)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PathPointType_Decode(V2xFac_PathPointType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.pathDeltaTime = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PATHPOINTTYPE;
	if (ret) {
	    /*Decode pathPosition */
	    ret = V2xFac_DeltaReferencePositionType_Decode((&(pVal->pathPosition)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode pathDeltaTime */
	        if (pVal->exist.pathDeltaTime) {
	        	ret = V2xFac_PathDeltaTimeType_Decode((&(pVal->pathDeltaTime)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && V2xFac_PathPointType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PathHistoryType_Initialize(V2xFac_PathHistoryType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 40) {
	    V2xFac_PathPointType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}

flag V2xFac_PathHistoryType_IsConstraintValid(const V2xFac_PathHistoryType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = (pVal->nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PATHHISTORYTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_PathPointType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_PathHistoryType_Encode(const V2xFac_PathHistoryType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_PathHistoryType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_PathPointType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PathHistoryType_Decode(V2xFac_PathHistoryType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PATHHISTORYTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_PathPointType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_PathHistoryType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TracesType_Initialize(V2xFac_TracesType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    V2xFac_PathHistoryType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_TracesType_IsConstraintValid(const V2xFac_TracesType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 7));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TRACESTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_PathHistoryType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_TracesType_Encode(const V2xFac_TracesType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_TracesType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 7);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_PathHistoryType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TracesType_Decode(V2xFac_TracesType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TRACESTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_PathHistoryType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_TracesType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PtActivationTypeType_Initialize(V2xFac_PtActivationTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_PtActivationTypeType_IsConstraintValid(const V2xFac_PtActivationTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PTACTIVATIONTYPETYPE; 

	return ret;
}

flag V2xFac_PtActivationTypeType_Encode(const V2xFac_PtActivationTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PtActivationTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PtActivationTypeType_Decode(V2xFac_PtActivationTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PTACTIVATIONTYPETYPE;

	return ret  && V2xFac_PtActivationTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PtActivationDataType_Initialize(V2xFac_PtActivationDataType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 20);
	pVal->nCount = 1;

}

flag V2xFac_PtActivationDataType_IsConstraintValid(const V2xFac_PtActivationDataType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 20));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PTACTIVATIONDATATYPE; 

	return ret;
}

flag V2xFac_PtActivationDataType_Encode(const V2xFac_PtActivationDataType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_PtActivationDataType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 20);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PtActivationDataType_Decode(V2xFac_PtActivationDataType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 20);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PTACTIVATIONDATATYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PTACTIVATIONDATATYPE;
	}

	return ret  && V2xFac_PtActivationDataType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PtActivationType_Initialize(V2xFac_PtActivationType* pVal)
{
	(void)pVal;



	/*set ptActivationType */
	V2xFac_PtActivationTypeType_Initialize((&(pVal->ptActivationType)));
	/*set ptActivationData */
	V2xFac_PtActivationDataType_Initialize((&(pVal->ptActivationData)));
}

flag V2xFac_PtActivationType_IsConstraintValid(const V2xFac_PtActivationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_PtActivationTypeType_IsConstraintValid((&(pVal->ptActivationType)), pErrCode);
    if (ret) {
        ret = V2xFac_PtActivationDataType_IsConstraintValid((&(pVal->ptActivationData)), pErrCode);
    }

	return ret;
}

flag V2xFac_PtActivationType_Encode(const V2xFac_PtActivationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PtActivationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode ptActivationType */
	    ret = V2xFac_PtActivationTypeType_Encode((&(pVal->ptActivationType)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode ptActivationData */
	        ret = V2xFac_PtActivationDataType_Encode((&(pVal->ptActivationData)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PtActivationType_Decode(V2xFac_PtActivationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode ptActivationType */
	ret = V2xFac_PtActivationTypeType_Decode((&(pVal->ptActivationType)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode ptActivationData */
	    ret = V2xFac_PtActivationDataType_Decode((&(pVal->ptActivationData)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_PtActivationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AccelerationControlType_Initialize(V2xFac_AccelerationControlType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_AccelerationControlType_IsConstraintValid(const V2xFac_AccelerationControlType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_AccelerationControlType_Encode(const V2xFac_AccelerationControlType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AccelerationControlType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AccelerationControlType_Decode(V2xFac_AccelerationControlType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ACCELERATIONCONTROLTYPE;

	return ret  && V2xFac_AccelerationControlType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SemiAxisLengthType_Initialize(V2xFac_SemiAxisLengthType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SemiAxisLengthType_IsConstraintValid(const V2xFac_SemiAxisLengthType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4095UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SEMIAXISLENGTHTYPE; 

	return ret;
}

flag V2xFac_SemiAxisLengthType_Encode(const V2xFac_SemiAxisLengthType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SemiAxisLengthType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4095);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SemiAxisLengthType_Decode(V2xFac_SemiAxisLengthType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4095);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SEMIAXISLENGTHTYPE;

	return ret  && V2xFac_SemiAxisLengthType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CauseCodeTypeType_Initialize(V2xFac_CauseCodeTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_CauseCodeTypeType_IsConstraintValid(const V2xFac_CauseCodeTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_CAUSECODETYPETYPE; 

	return ret;
}

flag V2xFac_CauseCodeTypeType_Encode(const V2xFac_CauseCodeTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CauseCodeTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CauseCodeTypeType_Decode(V2xFac_CauseCodeTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CAUSECODETYPETYPE;

	return ret  && V2xFac_CauseCodeTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SubCauseCodeTypeType_Initialize(V2xFac_SubCauseCodeTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SubCauseCodeTypeType_IsConstraintValid(const V2xFac_SubCauseCodeTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SUBCAUSECODETYPETYPE; 

	return ret;
}

flag V2xFac_SubCauseCodeTypeType_Encode(const V2xFac_SubCauseCodeTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SubCauseCodeTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SubCauseCodeTypeType_Decode(V2xFac_SubCauseCodeTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SUBCAUSECODETYPETYPE;

	return ret  && V2xFac_SubCauseCodeTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CauseCodeType_Initialize(V2xFac_CauseCodeType* pVal)
{
	(void)pVal;



	/*set causeCode */
	V2xFac_CauseCodeTypeType_Initialize((&(pVal->causeCode)));
	/*set subCauseCode */
	V2xFac_SubCauseCodeTypeType_Initialize((&(pVal->subCauseCode)));
}

flag V2xFac_CauseCodeType_IsConstraintValid(const V2xFac_CauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_CauseCodeTypeType_IsConstraintValid((&(pVal->causeCode)), pErrCode);
    if (ret) {
        ret = V2xFac_SubCauseCodeTypeType_IsConstraintValid((&(pVal->subCauseCode)), pErrCode);
    }

	return ret;
}

flag V2xFac_CauseCodeType_Encode(const V2xFac_CauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode causeCode */
	    ret = V2xFac_CauseCodeTypeType_Encode((&(pVal->causeCode)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode subCauseCode */
	        ret = V2xFac_SubCauseCodeTypeType_Encode((&(pVal->subCauseCode)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CauseCodeType_Decode(V2xFac_CauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode causeCode */
	ret = V2xFac_CauseCodeTypeType_Decode((&(pVal->causeCode)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode subCauseCode */
	    ret = V2xFac_SubCauseCodeTypeType_Decode((&(pVal->subCauseCode)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_CauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TrafficConditionSubCauseCodeType_Initialize(V2xFac_TrafficConditionSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_TrafficConditionSubCauseCodeType_IsConstraintValid(const V2xFac_TrafficConditionSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TRAFFICCONDITIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_TrafficConditionSubCauseCodeType_Encode(const V2xFac_TrafficConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TrafficConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TrafficConditionSubCauseCodeType_Decode(V2xFac_TrafficConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TRAFFICCONDITIONSUBCAUSECODETYPE;

	return ret  && V2xFac_TrafficConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AccidentSubCauseCodeType_Initialize(V2xFac_AccidentSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AccidentSubCauseCodeType_IsConstraintValid(const V2xFac_AccidentSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ACCIDENTSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_AccidentSubCauseCodeType_Encode(const V2xFac_AccidentSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AccidentSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AccidentSubCauseCodeType_Decode(V2xFac_AccidentSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ACCIDENTSUBCAUSECODETYPE;

	return ret  && V2xFac_AccidentSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RoadworksSubCauseCodeType_Initialize(V2xFac_RoadworksSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_RoadworksSubCauseCodeType_IsConstraintValid(const V2xFac_RoadworksSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ROADWORKSSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_RoadworksSubCauseCodeType_Encode(const V2xFac_RoadworksSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RoadworksSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RoadworksSubCauseCodeType_Decode(V2xFac_RoadworksSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSSUBCAUSECODETYPE;

	return ret  && V2xFac_RoadworksSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_Initialize(V2xFac_HumanPresenceOnTheRoadSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_IsConstraintValid(const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HUMANPRESENCEONTHEROADSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_Encode(const V2xFac_HumanPresenceOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_Decode(V2xFac_HumanPresenceOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HUMANPRESENCEONTHEROADSUBCAUSECODETYPE;

	return ret  && V2xFac_HumanPresenceOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_WrongWayDrivingSubCauseCodeType_Initialize(V2xFac_WrongWayDrivingSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_WrongWayDrivingSubCauseCodeType_IsConstraintValid(const V2xFac_WrongWayDrivingSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_WRONGWAYDRIVINGSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_WrongWayDrivingSubCauseCodeType_Encode(const V2xFac_WrongWayDrivingSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_WrongWayDrivingSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_WrongWayDrivingSubCauseCodeType_Decode(V2xFac_WrongWayDrivingSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_WRONGWAYDRIVINGSUBCAUSECODETYPE;

	return ret  && V2xFac_WrongWayDrivingSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_Initialize(V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_IsConstraintValid(const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_Encode(const V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_Decode(V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITIONSUBCAUSECODETYPE;

	return ret  && V2xFac_AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_Initialize(V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_IsConstraintValid(const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ADVERSEWEATHERCONDITION_ADHESIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_Encode(const V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_Decode(V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ADVERSEWEATHERCONDITION_ADHESIONSUBCAUSECODETYPE;

	return ret  && V2xFac_AdverseWeatherCondition_AdhesionSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_Initialize(V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_IsConstraintValid(const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ADVERSEWEATHERCONDITION_VISIBILITYSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_Encode(const V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_Decode(V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ADVERSEWEATHERCONDITION_VISIBILITYSUBCAUSECODETYPE;

	return ret  && V2xFac_AdverseWeatherCondition_VisibilitySubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_Initialize(V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_IsConstraintValid(const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ADVERSEWEATHERCONDITION_PRECIPITATIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_Encode(const V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_Decode(V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ADVERSEWEATHERCONDITION_PRECIPITATIONSUBCAUSECODETYPE;

	return ret  && V2xFac_AdverseWeatherCondition_PrecipitationSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SlowVehicleSubCauseCodeType_Initialize(V2xFac_SlowVehicleSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SlowVehicleSubCauseCodeType_IsConstraintValid(const V2xFac_SlowVehicleSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SLOWVEHICLESUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_SlowVehicleSubCauseCodeType_Encode(const V2xFac_SlowVehicleSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SlowVehicleSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SlowVehicleSubCauseCodeType_Decode(V2xFac_SlowVehicleSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SLOWVEHICLESUBCAUSECODETYPE;

	return ret  && V2xFac_SlowVehicleSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_StationaryVehicleSubCauseCodeType_Initialize(V2xFac_StationaryVehicleSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_StationaryVehicleSubCauseCodeType_IsConstraintValid(const V2xFac_StationaryVehicleSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STATIONARYVEHICLESUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_StationaryVehicleSubCauseCodeType_Encode(const V2xFac_StationaryVehicleSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_StationaryVehicleSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_StationaryVehicleSubCauseCodeType_Decode(V2xFac_StationaryVehicleSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLESUBCAUSECODETYPE;

	return ret  && V2xFac_StationaryVehicleSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HumanProblemSubCauseCodeType_Initialize(V2xFac_HumanProblemSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HumanProblemSubCauseCodeType_IsConstraintValid(const V2xFac_HumanProblemSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HUMANPROBLEMSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HumanProblemSubCauseCodeType_Encode(const V2xFac_HumanProblemSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HumanProblemSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HumanProblemSubCauseCodeType_Decode(V2xFac_HumanProblemSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HUMANPROBLEMSUBCAUSECODETYPE;

	return ret  && V2xFac_HumanProblemSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EmergencyVehicleApproachingSubCauseCodeType_Initialize(V2xFac_EmergencyVehicleApproachingSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_EmergencyVehicleApproachingSubCauseCodeType_IsConstraintValid(const V2xFac_EmergencyVehicleApproachingSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_EMERGENCYVEHICLEAPPROACHINGSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_EmergencyVehicleApproachingSubCauseCodeType_Encode(const V2xFac_EmergencyVehicleApproachingSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EmergencyVehicleApproachingSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EmergencyVehicleApproachingSubCauseCodeType_Decode(V2xFac_EmergencyVehicleApproachingSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EMERGENCYVEHICLEAPPROACHINGSUBCAUSECODETYPE;

	return ret  && V2xFac_EmergencyVehicleApproachingSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_Initialize(V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_IsConstraintValid(const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HAZARDOUSLOCATION_DANGEROUSCURVESUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_Encode(const V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_Decode(V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HAZARDOUSLOCATION_DANGEROUSCURVESUBCAUSECODETYPE;

	return ret  && V2xFac_HazardousLocation_DangerousCurveSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_Initialize(V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_IsConstraintValid(const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HAZARDOUSLOCATION_SURFACECONDITIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_Encode(const V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_Decode(V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HAZARDOUSLOCATION_SURFACECONDITIONSUBCAUSECODETYPE;

	return ret  && V2xFac_HazardousLocation_SurfaceConditionSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_Initialize(V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_IsConstraintValid(const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HAZARDOUSLOCATION_OBSTACLEONTHEROADSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_Encode(const V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_Decode(V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HAZARDOUSLOCATION_OBSTACLEONTHEROADSUBCAUSECODETYPE;

	return ret  && V2xFac_HazardousLocation_ObstacleOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_Initialize(V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_IsConstraintValid(const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HAZARDOUSLOCATION_ANIMALONTHEROADSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_Encode(const V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_Decode(V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HAZARDOUSLOCATION_ANIMALONTHEROADSUBCAUSECODETYPE;

	return ret  && V2xFac_HazardousLocation_AnimalOnTheRoadSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CollisionRiskSubCauseCodeType_Initialize(V2xFac_CollisionRiskSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_CollisionRiskSubCauseCodeType_IsConstraintValid(const V2xFac_CollisionRiskSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_COLLISIONRISKSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_CollisionRiskSubCauseCodeType_Encode(const V2xFac_CollisionRiskSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CollisionRiskSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CollisionRiskSubCauseCodeType_Decode(V2xFac_CollisionRiskSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_COLLISIONRISKSUBCAUSECODETYPE;

	return ret  && V2xFac_CollisionRiskSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SignalViolationSubCauseCodeType_Initialize(V2xFac_SignalViolationSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SignalViolationSubCauseCodeType_IsConstraintValid(const V2xFac_SignalViolationSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SIGNALVIOLATIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_SignalViolationSubCauseCodeType_Encode(const V2xFac_SignalViolationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SignalViolationSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SignalViolationSubCauseCodeType_Decode(V2xFac_SignalViolationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SIGNALVIOLATIONSUBCAUSECODETYPE;

	return ret  && V2xFac_SignalViolationSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_Initialize(V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_IsConstraintValid(const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_RESCUEANDRECOVERYWORKINPROGRESSSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_Encode(const V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_Decode(V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_RESCUEANDRECOVERYWORKINPROGRESSSUBCAUSECODETYPE;

	return ret  && V2xFac_RescueAndRecoveryWorkInProgressSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DangerousEndOfQueueSubCauseCodeType_Initialize(V2xFac_DangerousEndOfQueueSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_DangerousEndOfQueueSubCauseCodeType_IsConstraintValid(const V2xFac_DangerousEndOfQueueSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSENDOFQUEUESUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_DangerousEndOfQueueSubCauseCodeType_Encode(const V2xFac_DangerousEndOfQueueSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DangerousEndOfQueueSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DangerousEndOfQueueSubCauseCodeType_Decode(V2xFac_DangerousEndOfQueueSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSENDOFQUEUESUBCAUSECODETYPE;

	return ret  && V2xFac_DangerousEndOfQueueSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DangerousSituationSubCauseCodeType_Initialize(V2xFac_DangerousSituationSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_DangerousSituationSubCauseCodeType_IsConstraintValid(const V2xFac_DangerousSituationSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSSITUATIONSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_DangerousSituationSubCauseCodeType_Encode(const V2xFac_DangerousSituationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DangerousSituationSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DangerousSituationSubCauseCodeType_Decode(V2xFac_DangerousSituationSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSSITUATIONSUBCAUSECODETYPE;

	return ret  && V2xFac_DangerousSituationSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleBreakdownSubCauseCodeType_Initialize(V2xFac_VehicleBreakdownSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_VehicleBreakdownSubCauseCodeType_IsConstraintValid(const V2xFac_VehicleBreakdownSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLEBREAKDOWNSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_VehicleBreakdownSubCauseCodeType_Encode(const V2xFac_VehicleBreakdownSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleBreakdownSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleBreakdownSubCauseCodeType_Decode(V2xFac_VehicleBreakdownSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEBREAKDOWNSUBCAUSECODETYPE;

	return ret  && V2xFac_VehicleBreakdownSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PostCrashSubCauseCodeType_Initialize(V2xFac_PostCrashSubCauseCodeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_PostCrashSubCauseCodeType_IsConstraintValid(const V2xFac_PostCrashSubCauseCodeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSTCRASHSUBCAUSECODETYPE; 

	return ret;
}

flag V2xFac_PostCrashSubCauseCodeType_Encode(const V2xFac_PostCrashSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PostCrashSubCauseCodeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PostCrashSubCauseCodeType_Decode(V2xFac_PostCrashSubCauseCodeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSTCRASHSUBCAUSECODETYPE;

	return ret  && V2xFac_PostCrashSubCauseCodeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CurvatureValueType_Initialize(V2xFac_CurvatureValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_CurvatureValueType_IsConstraintValid(const V2xFac_CurvatureValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-30000LL <= (*(pVal))) && ((*(pVal)) <= 30001LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_CURVATUREVALUETYPE; 

	return ret;
}

flag V2xFac_CurvatureValueType_Encode(const V2xFac_CurvatureValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CurvatureValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -30000, 30001);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CurvatureValueType_Decode(V2xFac_CurvatureValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -30000, 30001);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CURVATUREVALUETYPE;

	return ret  && V2xFac_CurvatureValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CurvatureConfidenceType_Initialize(V2xFac_CurvatureConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_00002;
}

flag V2xFac_CurvatureConfidenceType_IsConstraintValid(const V2xFac_CurvatureConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_00002)) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0001)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0005)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_002)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_01)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_1)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_OUT_OF_RANGE)))) || (((*(pVal)) == v2XFAC_CURVATURE_CONFIDENCE_TYPE_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_CURVATURECONFIDENCETYPE; 

	return ret;
}

flag V2xFac_CurvatureConfidenceType_Encode(const V2xFac_CurvatureConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CurvatureConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_00002:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0001:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0005:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_002:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_01:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_OUT_OF_RANGE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case v2XFAC_CURVATURE_CONFIDENCE_TYPE_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_CURVATURECONFIDENCETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CurvatureConfidenceType_Decode(V2xFac_CurvatureConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CURVATURECONFIDENCETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_00002;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0001;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_0005;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_002;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_01;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_1;
	                break;
	            case 6: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_OUT_OF_RANGE;
	                break;
	            case 7: 
	                (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_CURVATURECONFIDENCETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_CURVATURE_CONFIDENCE_TYPE_ONE_PER_METER_0_00002;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_CurvatureConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CurvatureType_Initialize(V2xFac_CurvatureType* pVal)
{
	(void)pVal;



	/*set curvatureValue */
	V2xFac_CurvatureValueType_Initialize((&(pVal->curvatureValue)));
	/*set curvatureConfidence */
	V2xFac_CurvatureConfidenceType_Initialize((&(pVal->curvatureConfidence)));
}

flag V2xFac_CurvatureType_IsConstraintValid(const V2xFac_CurvatureType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_CurvatureValueType_IsConstraintValid((&(pVal->curvatureValue)), pErrCode);
    if (ret) {
        ret = V2xFac_CurvatureConfidenceType_IsConstraintValid((&(pVal->curvatureConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_CurvatureType_Encode(const V2xFac_CurvatureType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CurvatureType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode curvatureValue */
	    ret = V2xFac_CurvatureValueType_Encode((&(pVal->curvatureValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode curvatureConfidence */
	        ret = V2xFac_CurvatureConfidenceType_Encode((&(pVal->curvatureConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CurvatureType_Decode(V2xFac_CurvatureType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode curvatureValue */
	ret = V2xFac_CurvatureValueType_Decode((&(pVal->curvatureValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode curvatureConfidence */
	    ret = V2xFac_CurvatureConfidenceType_Decode((&(pVal->curvatureConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_CurvatureType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CurvatureCalculationModeType_Initialize(V2xFac_CurvatureCalculationModeType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_USED;
}

flag V2xFac_CurvatureCalculationModeType_IsConstraintValid(const V2xFac_CurvatureCalculationModeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_USED)) || (((*(pVal)) == v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_NOT_USED)))) || (((*(pVal)) == v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_CURVATURECALCULATIONMODETYPE; 

	return ret;
}

flag V2xFac_CurvatureCalculationModeType_Encode(const V2xFac_CurvatureCalculationModeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CurvatureCalculationModeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_USED:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_NOT_USED:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_CURVATURECALCULATIONMODETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CurvatureCalculationModeType_Decode(V2xFac_CurvatureCalculationModeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CURVATURECALCULATIONMODETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_USED;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_NOT_USED;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_CURVATURECALCULATIONMODETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_CURVATURE_CALCULATION_MODE_TYPE_YAWRATE_USED;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_CurvatureCalculationModeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HeadingValueType_Initialize(V2xFac_HeadingValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_HeadingValueType_IsConstraintValid(const V2xFac_HeadingValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 3601UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HEADINGVALUETYPE; 

	return ret;
}

flag V2xFac_HeadingValueType_Encode(const V2xFac_HeadingValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HeadingValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 3601);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HeadingValueType_Decode(V2xFac_HeadingValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 3601);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HEADINGVALUETYPE;

	return ret  && V2xFac_HeadingValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PosConfidenceEllipseType_Initialize(V2xFac_PosConfidenceEllipseType* pVal)
{
	(void)pVal;



	/*set semiMajorConfidence */
	V2xFac_SemiAxisLengthType_Initialize((&(pVal->semiMajorConfidence)));
	/*set semiMinorConfidence */
	V2xFac_SemiAxisLengthType_Initialize((&(pVal->semiMinorConfidence)));
	/*set semiMajorOrientation */
	V2xFac_HeadingValueType_Initialize((&(pVal->semiMajorOrientation)));
}

flag V2xFac_PosConfidenceEllipseType_IsConstraintValid(const V2xFac_PosConfidenceEllipseType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_SemiAxisLengthType_IsConstraintValid((&(pVal->semiMajorConfidence)), pErrCode);
    if (ret) {
        ret = V2xFac_SemiAxisLengthType_IsConstraintValid((&(pVal->semiMinorConfidence)), pErrCode);
        if (ret) {
            ret = V2xFac_HeadingValueType_IsConstraintValid((&(pVal->semiMajorOrientation)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_PosConfidenceEllipseType_Encode(const V2xFac_PosConfidenceEllipseType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PosConfidenceEllipseType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode semiMajorConfidence */
	    ret = V2xFac_SemiAxisLengthType_Encode((&(pVal->semiMajorConfidence)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode semiMinorConfidence */
	        ret = V2xFac_SemiAxisLengthType_Encode((&(pVal->semiMinorConfidence)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode semiMajorOrientation */
	            ret = V2xFac_HeadingValueType_Encode((&(pVal->semiMajorOrientation)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PosConfidenceEllipseType_Decode(V2xFac_PosConfidenceEllipseType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode semiMajorConfidence */
	ret = V2xFac_SemiAxisLengthType_Decode((&(pVal->semiMajorConfidence)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode semiMinorConfidence */
	    ret = V2xFac_SemiAxisLengthType_Decode((&(pVal->semiMinorConfidence)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode semiMajorOrientation */
	        ret = V2xFac_HeadingValueType_Decode((&(pVal->semiMajorOrientation)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_PosConfidenceEllipseType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ReferencePositionType_Initialize(V2xFac_ReferencePositionType* pVal)
{
	(void)pVal;



	/*set latitude */
	V2xFac_LatitudeType_Initialize((&(pVal->latitude)));
	/*set longitude */
	V2xFac_LongitudeType_Initialize((&(pVal->longitude)));
	/*set posConfidenceEllipse */
	V2xFac_PosConfidenceEllipseType_Initialize((&(pVal->posConfidenceEllipse)));
	/*set altitude */
	V2xFac_AltitudeType_Initialize((&(pVal->altitude)));
}

flag V2xFac_ReferencePositionType_IsConstraintValid(const V2xFac_ReferencePositionType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LatitudeType_IsConstraintValid((&(pVal->latitude)), pErrCode);
    if (ret) {
        ret = V2xFac_LongitudeType_IsConstraintValid((&(pVal->longitude)), pErrCode);
        if (ret) {
            ret = V2xFac_PosConfidenceEllipseType_IsConstraintValid((&(pVal->posConfidenceEllipse)), pErrCode);
            if (ret) {
                ret = V2xFac_AltitudeType_IsConstraintValid((&(pVal->altitude)), pErrCode);
            }
        }
    }

	return ret;
}

flag V2xFac_ReferencePositionType_Encode(const V2xFac_ReferencePositionType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ReferencePositionType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode latitude */
	    ret = V2xFac_LatitudeType_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode longitude */
	        ret = V2xFac_LongitudeType_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode posConfidenceEllipse */
	            ret = V2xFac_PosConfidenceEllipseType_Encode((&(pVal->posConfidenceEllipse)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode altitude */
	                ret = V2xFac_AltitudeType_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ReferencePositionType_Decode(V2xFac_ReferencePositionType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode latitude */
	ret = V2xFac_LatitudeType_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode longitude */
	    ret = V2xFac_LongitudeType_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode posConfidenceEllipse */
	        ret = V2xFac_PosConfidenceEllipseType_Decode((&(pVal->posConfidenceEllipse)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode altitude */
	            ret = V2xFac_AltitudeType_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && V2xFac_ReferencePositionType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ItineraryPathType_Initialize(V2xFac_ItineraryPathType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 40) {
	    V2xFac_ReferencePositionType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_ItineraryPathType_IsConstraintValid(const V2xFac_ItineraryPathType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 40));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ITINERARYPATHTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_ReferencePositionType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_ItineraryPathType_Encode(const V2xFac_ItineraryPathType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_ItineraryPathType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_ReferencePositionType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ItineraryPathType_Decode(V2xFac_ItineraryPathType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 40);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ITINERARYPATHTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_ReferencePositionType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_ItineraryPathType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HeadingConfidenceType_Initialize(V2xFac_HeadingConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_HeadingConfidenceType_IsConstraintValid(const V2xFac_HeadingConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 127UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HEADINGCONFIDENCETYPE; 

	return ret;
}

flag V2xFac_HeadingConfidenceType_Encode(const V2xFac_HeadingConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HeadingConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HeadingConfidenceType_Decode(V2xFac_HeadingConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HEADINGCONFIDENCETYPE;

	return ret  && V2xFac_HeadingConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HeadingType_Initialize(V2xFac_HeadingType* pVal)
{
	(void)pVal;



	/*set headingValue */
	V2xFac_HeadingValueType_Initialize((&(pVal->headingValue)));
	/*set headingConfidence */
	V2xFac_HeadingConfidenceType_Initialize((&(pVal->headingConfidence)));
}

flag V2xFac_HeadingType_IsConstraintValid(const V2xFac_HeadingType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_HeadingValueType_IsConstraintValid((&(pVal->headingValue)), pErrCode);
    if (ret) {
        ret = V2xFac_HeadingConfidenceType_IsConstraintValid((&(pVal->headingConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_HeadingType_Encode(const V2xFac_HeadingType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HeadingType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode headingValue */
	    ret = V2xFac_HeadingValueType_Encode((&(pVal->headingValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode headingConfidence */
	        ret = V2xFac_HeadingConfidenceType_Encode((&(pVal->headingConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HeadingType_Decode(V2xFac_HeadingType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode headingValue */
	ret = V2xFac_HeadingValueType_Decode((&(pVal->headingValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode headingConfidence */
	    ret = V2xFac_HeadingConfidenceType_Decode((&(pVal->headingConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_HeadingType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LanePositionType_Initialize(V2xFac_LanePositionType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_LanePositionType_IsConstraintValid(const V2xFac_LanePositionType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1LL <= (*(pVal))) && ((*(pVal)) <= 14LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_LANEPOSITIONTYPE; 

	return ret;
}

flag V2xFac_LanePositionType_Encode(const V2xFac_LanePositionType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LanePositionType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -1, 14);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LanePositionType_Decode(V2xFac_LanePositionType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -1, 14);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LANEPOSITIONTYPE;

	return ret  && V2xFac_LanePositionType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HardShoulderStatusType_Initialize(V2xFac_HardShoulderStatusType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_STOPPING;
}

flag V2xFac_HardShoulderStatusType_IsConstraintValid(const V2xFac_HardShoulderStatusType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_STOPPING)) || (((*(pVal)) == v2XFAC_HARD_SHOULDER_STATUS_TYPE_CLOSED)))) || (((*(pVal)) == v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_DRIVING)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HARDSHOULDERSTATUSTYPE; 

	return ret;
}

flag V2xFac_HardShoulderStatusType_Encode(const V2xFac_HardShoulderStatusType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HardShoulderStatusType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_STOPPING:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case v2XFAC_HARD_SHOULDER_STATUS_TYPE_CLOSED:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_DRIVING:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_HARDSHOULDERSTATUSTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HardShoulderStatusType_Decode(V2xFac_HardShoulderStatusType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HARDSHOULDERSTATUSTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_STOPPING;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_HARD_SHOULDER_STATUS_TYPE_CLOSED;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_DRIVING;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_HARDSHOULDERSTATUSTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_HARD_SHOULDER_STATUS_TYPE_AVAILABLE_FOR_STOPPING;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_HardShoulderStatusType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DrivingLaneStatusType_Initialize(V2xFac_DrivingLaneStatusType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 16/8);

	pVal->nCount = 1;
}

flag V2xFac_DrivingLaneStatusType_IsConstraintValid(const V2xFac_DrivingLaneStatusType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 14));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DRIVINGLANESTATUSTYPE; 

	return ret;
}

flag V2xFac_DrivingLaneStatusType_Encode(const V2xFac_DrivingLaneStatusType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DrivingLaneStatusType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 14);
	    BitStream_AppendBits(pBitStrm, pVal->arr, pVal->nCount);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DrivingLaneStatusType_Decode(V2xFac_DrivingLaneStatusType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 14);
	if (ret) {
		pVal->nCount = (long)nCount;
		ret = BitStream_ReadBits(pBitStrm, pVal->arr, pVal->nCount);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DRIVINGLANESTATUSTYPE;
	}

	return ret  && V2xFac_DrivingLaneStatusType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ClosedLanesType_Initialize(V2xFac_ClosedLanesType* pVal)
{
	(void)pVal;



	/*set hardShoulderStatus */
	pVal->exist.hardShoulderStatus = 1;
	V2xFac_HardShoulderStatusType_Initialize((&(pVal->hardShoulderStatus)));
	/*set drivingLaneStatus */
	V2xFac_DrivingLaneStatusType_Initialize((&(pVal->drivingLaneStatus)));
}

flag V2xFac_ClosedLanesType_IsConstraintValid(const V2xFac_ClosedLanesType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.hardShoulderStatus) {
    	ret = V2xFac_HardShoulderStatusType_IsConstraintValid((&(pVal->hardShoulderStatus)), pErrCode);
    }
    if (ret) {
        ret = V2xFac_DrivingLaneStatusType_IsConstraintValid((&(pVal->drivingLaneStatus)), pErrCode);
    }

	return ret;
}

flag V2xFac_ClosedLanesType_Encode(const V2xFac_ClosedLanesType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ClosedLanesType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.hardShoulderStatus);
	    if (ret) {
	        /*Encode hardShoulderStatus */
	        if (pVal->exist.hardShoulderStatus) {
	        	ret = V2xFac_HardShoulderStatusType_Encode((&(pVal->hardShoulderStatus)), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode drivingLaneStatus */
	            ret = V2xFac_DrivingLaneStatusType_Encode((&(pVal->drivingLaneStatus)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ClosedLanesType_Decode(V2xFac_ClosedLanesType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.hardShoulderStatus = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CLOSEDLANESTYPE;
	if (ret) {
	    /*Decode hardShoulderStatus */
	    if (pVal->exist.hardShoulderStatus) {
	    	ret = V2xFac_HardShoulderStatusType_Decode((&(pVal->hardShoulderStatus)), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode drivingLaneStatus */
	        ret = V2xFac_DrivingLaneStatusType_Decode((&(pVal->drivingLaneStatus)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_ClosedLanesType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PerformanceClassType_Initialize(V2xFac_PerformanceClassType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_PerformanceClassType_IsConstraintValid(const V2xFac_PerformanceClassType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PERFORMANCECLASSTYPE; 

	return ret;
}

flag V2xFac_PerformanceClassType_Encode(const V2xFac_PerformanceClassType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PerformanceClassType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PerformanceClassType_Decode(V2xFac_PerformanceClassType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PERFORMANCECLASSTYPE;

	return ret  && V2xFac_PerformanceClassType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpeedValueType_Initialize(V2xFac_SpeedValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SpeedValueType_IsConstraintValid(const V2xFac_SpeedValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 16383UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SPEEDVALUETYPE; 

	return ret;
}

flag V2xFac_SpeedValueType_Encode(const V2xFac_SpeedValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpeedValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16383);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpeedValueType_Decode(V2xFac_SpeedValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16383);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SPEEDVALUETYPE;

	return ret  && V2xFac_SpeedValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpeedConfidenceType_Initialize(V2xFac_SpeedConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_SpeedConfidenceType_IsConstraintValid(const V2xFac_SpeedConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 127UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SPEEDCONFIDENCETYPE; 

	return ret;
}

flag V2xFac_SpeedConfidenceType_Encode(const V2xFac_SpeedConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpeedConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpeedConfidenceType_Decode(V2xFac_SpeedConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SPEEDCONFIDENCETYPE;

	return ret  && V2xFac_SpeedConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpeedType_Initialize(V2xFac_SpeedType* pVal)
{
	(void)pVal;



	/*set speedValue */
	V2xFac_SpeedValueType_Initialize((&(pVal->speedValue)));
	/*set speedConfidence */
	V2xFac_SpeedConfidenceType_Initialize((&(pVal->speedConfidence)));
}

flag V2xFac_SpeedType_IsConstraintValid(const V2xFac_SpeedType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_SpeedValueType_IsConstraintValid((&(pVal->speedValue)), pErrCode);
    if (ret) {
        ret = V2xFac_SpeedConfidenceType_IsConstraintValid((&(pVal->speedConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_SpeedType_Encode(const V2xFac_SpeedType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpeedType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speedValue */
	    ret = V2xFac_SpeedValueType_Encode((&(pVal->speedValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode speedConfidence */
	        ret = V2xFac_SpeedConfidenceType_Encode((&(pVal->speedConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpeedType_Decode(V2xFac_SpeedType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode speedValue */
	ret = V2xFac_SpeedValueType_Decode((&(pVal->speedValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode speedConfidence */
	    ret = V2xFac_SpeedConfidenceType_Decode((&(pVal->speedConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_SpeedType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleMassType_Initialize(V2xFac_VehicleMassType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_VehicleMassType_IsConstraintValid(const V2xFac_VehicleMassType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 1024UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLEMASSTYPE; 

	return ret;
}

flag V2xFac_VehicleMassType_Encode(const V2xFac_VehicleMassType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleMassType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 1024);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleMassType_Decode(V2xFac_VehicleMassType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 1024);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEMASSTYPE;

	return ret  && V2xFac_VehicleMassType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DriveDirectionType_Initialize(V2xFac_DriveDirectionType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_DRIVE_DIRECTION_TYPE_FORWARD;
}

flag V2xFac_DriveDirectionType_IsConstraintValid(const V2xFac_DriveDirectionType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((*(pVal)) == v2XFAC_DRIVE_DIRECTION_TYPE_FORWARD)) || (((*(pVal)) == v2XFAC_DRIVE_DIRECTION_TYPE_BACKWARD)))) || (((*(pVal)) == v2XFAC_DRIVE_DIRECTION_TYPE_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DRIVEDIRECTIONTYPE; 

	return ret;
}

flag V2xFac_DriveDirectionType_Encode(const V2xFac_DriveDirectionType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DriveDirectionType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_DRIVE_DIRECTION_TYPE_FORWARD:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case v2XFAC_DRIVE_DIRECTION_TYPE_BACKWARD:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case v2XFAC_DRIVE_DIRECTION_TYPE_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_DRIVEDIRECTIONTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DriveDirectionType_Decode(V2xFac_DriveDirectionType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DRIVEDIRECTIONTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_DRIVE_DIRECTION_TYPE_FORWARD;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_DRIVE_DIRECTION_TYPE_BACKWARD;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_DRIVE_DIRECTION_TYPE_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_DRIVEDIRECTIONTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_DRIVE_DIRECTION_TYPE_FORWARD;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_DriveDirectionType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EmbarkationStatusType_Initialize(V2xFac_EmbarkationStatusType* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag V2xFac_EmbarkationStatusType_IsConstraintValid(const V2xFac_EmbarkationStatusType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_EmbarkationStatusType_Encode(const V2xFac_EmbarkationStatusType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EmbarkationStatusType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EmbarkationStatusType_Decode(V2xFac_EmbarkationStatusType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EMBARKATIONSTATUSTYPE;

	return ret  && V2xFac_EmbarkationStatusType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LongitudinalAccelerationValueType_Initialize(V2xFac_LongitudinalAccelerationValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_LongitudinalAccelerationValueType_IsConstraintValid(const V2xFac_LongitudinalAccelerationValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-160LL <= (*(pVal))) && ((*(pVal)) <= 161LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_LONGITUDINALACCELERATIONVALUETYPE; 

	return ret;
}

flag V2xFac_LongitudinalAccelerationValueType_Encode(const V2xFac_LongitudinalAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LongitudinalAccelerationValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -160, 161);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LongitudinalAccelerationValueType_Decode(V2xFac_LongitudinalAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -160, 161);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LONGITUDINALACCELERATIONVALUETYPE;

	return ret  && V2xFac_LongitudinalAccelerationValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AccelerationConfidenceType_Initialize(V2xFac_AccelerationConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_AccelerationConfidenceType_IsConstraintValid(const V2xFac_AccelerationConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 102UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ACCELERATIONCONFIDENCETYPE; 

	return ret;
}

flag V2xFac_AccelerationConfidenceType_Encode(const V2xFac_AccelerationConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AccelerationConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 102);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AccelerationConfidenceType_Decode(V2xFac_AccelerationConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 102);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ACCELERATIONCONFIDENCETYPE;

	return ret  && V2xFac_AccelerationConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LongitudinalAccelerationType_Initialize(V2xFac_LongitudinalAccelerationType* pVal)
{
	(void)pVal;



	/*set longitudinalAccelerationValue */
	V2xFac_LongitudinalAccelerationValueType_Initialize((&(pVal->longitudinalAccelerationValue)));
	/*set longitudinalAccelerationConfidence */
	V2xFac_AccelerationConfidenceType_Initialize((&(pVal->longitudinalAccelerationConfidence)));
}

flag V2xFac_LongitudinalAccelerationType_IsConstraintValid(const V2xFac_LongitudinalAccelerationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LongitudinalAccelerationValueType_IsConstraintValid((&(pVal->longitudinalAccelerationValue)), pErrCode);
    if (ret) {
        ret = V2xFac_AccelerationConfidenceType_IsConstraintValid((&(pVal->longitudinalAccelerationConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_LongitudinalAccelerationType_Encode(const V2xFac_LongitudinalAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LongitudinalAccelerationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode longitudinalAccelerationValue */
	    ret = V2xFac_LongitudinalAccelerationValueType_Encode((&(pVal->longitudinalAccelerationValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode longitudinalAccelerationConfidence */
	        ret = V2xFac_AccelerationConfidenceType_Encode((&(pVal->longitudinalAccelerationConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LongitudinalAccelerationType_Decode(V2xFac_LongitudinalAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode longitudinalAccelerationValue */
	ret = V2xFac_LongitudinalAccelerationValueType_Decode((&(pVal->longitudinalAccelerationValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode longitudinalAccelerationConfidence */
	    ret = V2xFac_AccelerationConfidenceType_Decode((&(pVal->longitudinalAccelerationConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_LongitudinalAccelerationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LateralAccelerationValueType_Initialize(V2xFac_LateralAccelerationValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_LateralAccelerationValueType_IsConstraintValid(const V2xFac_LateralAccelerationValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-160LL <= (*(pVal))) && ((*(pVal)) <= 161LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_LATERALACCELERATIONVALUETYPE; 

	return ret;
}

flag V2xFac_LateralAccelerationValueType_Encode(const V2xFac_LateralAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LateralAccelerationValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -160, 161);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LateralAccelerationValueType_Decode(V2xFac_LateralAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -160, 161);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LATERALACCELERATIONVALUETYPE;

	return ret  && V2xFac_LateralAccelerationValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LateralAccelerationType_Initialize(V2xFac_LateralAccelerationType* pVal)
{
	(void)pVal;



	/*set lateralAccelerationValue */
	V2xFac_LateralAccelerationValueType_Initialize((&(pVal->lateralAccelerationValue)));
	/*set lateralAccelerationConfidence */
	V2xFac_AccelerationConfidenceType_Initialize((&(pVal->lateralAccelerationConfidence)));
}

flag V2xFac_LateralAccelerationType_IsConstraintValid(const V2xFac_LateralAccelerationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LateralAccelerationValueType_IsConstraintValid((&(pVal->lateralAccelerationValue)), pErrCode);
    if (ret) {
        ret = V2xFac_AccelerationConfidenceType_IsConstraintValid((&(pVal->lateralAccelerationConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_LateralAccelerationType_Encode(const V2xFac_LateralAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LateralAccelerationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode lateralAccelerationValue */
	    ret = V2xFac_LateralAccelerationValueType_Encode((&(pVal->lateralAccelerationValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lateralAccelerationConfidence */
	        ret = V2xFac_AccelerationConfidenceType_Encode((&(pVal->lateralAccelerationConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LateralAccelerationType_Decode(V2xFac_LateralAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode lateralAccelerationValue */
	ret = V2xFac_LateralAccelerationValueType_Decode((&(pVal->lateralAccelerationValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lateralAccelerationConfidence */
	    ret = V2xFac_AccelerationConfidenceType_Decode((&(pVal->lateralAccelerationConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_LateralAccelerationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VerticalAccelerationValueType_Initialize(V2xFac_VerticalAccelerationValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_VerticalAccelerationValueType_IsConstraintValid(const V2xFac_VerticalAccelerationValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-160LL <= (*(pVal))) && ((*(pVal)) <= 161LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VERTICALACCELERATIONVALUETYPE; 

	return ret;
}

flag V2xFac_VerticalAccelerationValueType_Encode(const V2xFac_VerticalAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VerticalAccelerationValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -160, 161);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VerticalAccelerationValueType_Decode(V2xFac_VerticalAccelerationValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -160, 161);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VERTICALACCELERATIONVALUETYPE;

	return ret  && V2xFac_VerticalAccelerationValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VerticalAccelerationType_Initialize(V2xFac_VerticalAccelerationType* pVal)
{
	(void)pVal;



	/*set verticalAccelerationValue */
	V2xFac_VerticalAccelerationValueType_Initialize((&(pVal->verticalAccelerationValue)));
	/*set verticalAccelerationConfidence */
	V2xFac_AccelerationConfidenceType_Initialize((&(pVal->verticalAccelerationConfidence)));
}

flag V2xFac_VerticalAccelerationType_IsConstraintValid(const V2xFac_VerticalAccelerationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_VerticalAccelerationValueType_IsConstraintValid((&(pVal->verticalAccelerationValue)), pErrCode);
    if (ret) {
        ret = V2xFac_AccelerationConfidenceType_IsConstraintValid((&(pVal->verticalAccelerationConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_VerticalAccelerationType_Encode(const V2xFac_VerticalAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VerticalAccelerationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode verticalAccelerationValue */
	    ret = V2xFac_VerticalAccelerationValueType_Encode((&(pVal->verticalAccelerationValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode verticalAccelerationConfidence */
	        ret = V2xFac_AccelerationConfidenceType_Encode((&(pVal->verticalAccelerationConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VerticalAccelerationType_Decode(V2xFac_VerticalAccelerationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode verticalAccelerationValue */
	ret = V2xFac_VerticalAccelerationValueType_Decode((&(pVal->verticalAccelerationValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode verticalAccelerationConfidence */
	    ret = V2xFac_AccelerationConfidenceType_Decode((&(pVal->verticalAccelerationConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_VerticalAccelerationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_StationTypeType_Initialize(V2xFac_StationTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_StationTypeType_IsConstraintValid(const V2xFac_StationTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STATIONTYPETYPE; 

	return ret;
}

flag V2xFac_StationTypeType_Encode(const V2xFac_StationTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_StationTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_StationTypeType_Decode(V2xFac_StationTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONTYPETYPE;

	return ret  && V2xFac_StationTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RestrictedTypesType_Initialize(V2xFac_RestrictedTypesType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    V2xFac_StationTypeType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_RestrictedTypesType_IsConstraintValid(const V2xFac_RestrictedTypesType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_RESTRICTEDTYPESTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_StationTypeType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_RestrictedTypesType_Encode(const V2xFac_RestrictedTypesType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_RestrictedTypesType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_StationTypeType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RestrictedTypesType_Decode(V2xFac_RestrictedTypesType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_RESTRICTEDTYPESTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_StationTypeType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_RestrictedTypesType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ExteriorLightsType_Initialize(V2xFac_ExteriorLightsType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_ExteriorLightsType_IsConstraintValid(const V2xFac_ExteriorLightsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_ExteriorLightsType_Encode(const V2xFac_ExteriorLightsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ExteriorLightsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 8);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ExteriorLightsType_Decode(V2xFac_ExteriorLightsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 8);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EXTERIORLIGHTSTYPE;

	return ret  && V2xFac_ExteriorLightsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DangerousGoodsBasicType_Initialize(V2xFac_DangerousGoodsBasicType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_1;
}

flag V2xFac_DangerousGoodsBasicType_IsConstraintValid(const V2xFac_DangerousGoodsBasicType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((((((((((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_1)) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_2)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_3)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_4)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_5)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_6)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_GASES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_NON_FLAMMABLE_GASES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_TOXIC_GASES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_LIQUIDS)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_SOLIDS)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_LIBLE_TO_SPONTANEOUS_COMBUSTION)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_EMITTING_FLAMMABLE_GASES_UPON_CONTACT_WITH_WATER)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_OXIDIZING_SUBSTANCES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_ORGANIC_PEROXIDES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_TOXIC_SUBSTANCES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_INFECTIOUS_SUBSTANCES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_RADIOACTIVE_MATERIAL)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_CORROSIVE_SUBSTANCES)))) || (((*(pVal)) == v2XFAC_DANGEROUSGOODSBASIC_MISCELLANEOUS_DANGEROUS_SUBSTANCES)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSGOODSBASICTYPE; 

	return ret;
}

flag V2xFac_DangerousGoodsBasicType_Encode(const V2xFac_DangerousGoodsBasicType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DangerousGoodsBasicType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_3:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_4:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_5:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_6:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_GASES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_NON_FLAMMABLE_GASES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_TOXIC_GASES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_LIQUIDS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_SOLIDS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_LIBLE_TO_SPONTANEOUS_COMBUSTION:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_EMITTING_FLAMMABLE_GASES_UPON_CONTACT_WITH_WATER:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_OXIDIZING_SUBSTANCES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_ORGANIC_PEROXIDES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_TOXIC_SUBSTANCES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_INFECTIOUS_SUBSTANCES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 16, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_RADIOACTIVE_MATERIAL:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 17, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_CORROSIVE_SUBSTANCES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 18, 0, 19);
	        	break;
	        case v2XFAC_DANGEROUSGOODSBASIC_MISCELLANEOUS_DANGEROUS_SUBSTANCES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 19, 0, 19);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_DANGEROUSGOODSBASICTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DangerousGoodsBasicType_Decode(V2xFac_DangerousGoodsBasicType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 19);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSBASICTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_1;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_2;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_3;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_4;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_5;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_6;
	                break;
	            case 6: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_GASES;
	                break;
	            case 7: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_NON_FLAMMABLE_GASES;
	                break;
	            case 8: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_TOXIC_GASES;
	                break;
	            case 9: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_LIQUIDS;
	                break;
	            case 10: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_FLAMMABLE_SOLIDS;
	                break;
	            case 11: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_LIBLE_TO_SPONTANEOUS_COMBUSTION;
	                break;
	            case 12: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_SUBSTANCES_EMITTING_FLAMMABLE_GASES_UPON_CONTACT_WITH_WATER;
	                break;
	            case 13: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_OXIDIZING_SUBSTANCES;
	                break;
	            case 14: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_ORGANIC_PEROXIDES;
	                break;
	            case 15: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_TOXIC_SUBSTANCES;
	                break;
	            case 16: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_INFECTIOUS_SUBSTANCES;
	                break;
	            case 17: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_RADIOACTIVE_MATERIAL;
	                break;
	            case 18: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_CORROSIVE_SUBSTANCES;
	                break;
	            case 19: 
	                (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_MISCELLANEOUS_DANGEROUS_SUBSTANCES;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSBASICTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_DANGEROUSGOODSBASIC_EXPLOSIVES_1;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_DangerousGoodsBasicType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DangerousGoodsExtendedType_unNumber_Initialize(V2xFac_DangerousGoodsExtendedType_unNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void V2xFac_DangerousGoodsExtendedType_emergencyActionCode_Initialize(V2xFac_DangerousGoodsExtendedType_emergencyActionCode val)
{
	(void)val;


	memset(val, 0x0, 25);

}
void V2xFac_DangerousGoodsExtendedType_phoneNumber_Initialize(V2xFac_DangerousGoodsExtendedType_phoneNumber val)
{
	(void)val;


	memset(val, 0x0, 25);

}
void V2xFac_DangerousGoodsExtendedType_companyName_Initialize(V2xFac_DangerousGoodsExtendedType_companyName val)
{
	(void)val;


	memset(val, 0x0, 25);

}
void V2xFac_DangerousGoodsExtendedType_Initialize(V2xFac_DangerousGoodsExtendedType* pVal)
{
	(void)pVal;



	/*set dangerousGoodsType */
	V2xFac_DangerousGoodsBasicType_Initialize((&(pVal->dangerousGoodsType)));
	/*set unNumber */
	V2xFac_DangerousGoodsExtendedType_unNumber_Initialize((&(pVal->unNumber)));
	/*set elevatedTemperature */
	pVal->elevatedTemperature = FALSE;
	/*set tunnelsRestricted */
	pVal->tunnelsRestricted = FALSE;
	/*set limitedQuantity */
	pVal->limitedQuantity = FALSE;
	/*set emergencyActionCode */
	pVal->exist.emergencyActionCode = 1;
	V2xFac_DangerousGoodsExtendedType_emergencyActionCode_Initialize(pVal->emergencyActionCode);
	/*set phoneNumber */
	pVal->exist.phoneNumber = 1;
	V2xFac_DangerousGoodsExtendedType_phoneNumber_Initialize(pVal->phoneNumber);
	/*set companyName */
	pVal->exist.companyName = 1;
	V2xFac_DangerousGoodsExtendedType_companyName_Initialize(pVal->companyName);
}

flag V2xFac_DangerousGoodsExtendedType_IsConstraintValid(const V2xFac_DangerousGoodsExtendedType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_DangerousGoodsBasicType_IsConstraintValid((&(pVal->dangerousGoodsType)), pErrCode);
    if (ret) {
        ret = (pVal->unNumber <= 9999UL);
        *pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_UNNUMBER; 
        if (ret) {
            if (pVal->exist.emergencyActionCode) {
            	ret = ((1 <= strlen(pVal->emergencyActionCode)) && (strlen(pVal->emergencyActionCode) <= 24));
            	*pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_EMERGENCYACTIONCODE; 
            }
            if (ret) {
                if (pVal->exist.phoneNumber) {
                	ret = ((1 <= strlen(pVal->phoneNumber)) && (strlen(pVal->phoneNumber) <= 24));
                	*pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_PHONENUMBER; 
                }
                if (ret) {
                    if (pVal->exist.companyName) {
                    	ret = ((1 <= strlen(pVal->companyName)) && (strlen(pVal->companyName) <= 24));
                    	*pErrCode = ret ? 0 :  ERR_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_COMPANYNAME; 
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_DangerousGoodsExtendedType_Encode(const V2xFac_DangerousGoodsExtendedType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	asn1SccSint nStringLength;
	ret = bCheckConstraints ? V2xFac_DangerousGoodsExtendedType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.emergencyActionCode);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.phoneNumber);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.companyName);
	            if (ret) {
	                /*Encode dangerousGoodsType */
	                ret = V2xFac_DangerousGoodsBasicType_Encode((&(pVal->dangerousGoodsType)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode unNumber */
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->unNumber, 0, 9999);
	                    if (ret) {
	                        /*Encode elevatedTemperature */
	                        BitStream_AppendBit(pBitStrm,pVal->elevatedTemperature);
	                        if (ret) {
	                            /*Encode tunnelsRestricted */
	                            BitStream_AppendBit(pBitStrm,pVal->tunnelsRestricted);
	                            if (ret) {
	                                /*Encode limitedQuantity */
	                                BitStream_AppendBit(pBitStrm,pVal->limitedQuantity);
	                                if (ret) {
	                                    /*Encode emergencyActionCode */
	                                    if (pVal->exist.emergencyActionCode) {
	                                    	nStringLength = strlen(pVal->emergencyActionCode);
	                                    	/*ret = nStringLength >= 1 && nStringLength <= 24;*/
	                                    	BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 24);
	                                    		
	                                    	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                    	{
	                                    		BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->emergencyActionCode[i1], 0, 127);
	                                    	}

	                                    }
	                                    if (ret) {
	                                        /*Encode phoneNumber */
	                                        if (pVal->exist.phoneNumber) {
	                                        	nStringLength = strlen(pVal->phoneNumber);
	                                        	/*ret = nStringLength >= 1 && nStringLength <= 24;*/
	                                        	BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 24);
	                                        		
	                                        	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                        	{
	                                        		BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->phoneNumber[i1], 0, 127);
	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Encode companyName */
	                                            if (pVal->exist.companyName) {
	                                            	nStringLength = strlen(pVal->companyName);
	                                            	/*ret = nStringLength >= 1 && nStringLength <= 24;*/
	                                            	BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 24);
	                                            		
	                                            	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                            	{
	                                            		BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->companyName[i1], 0, 127);
	                                            	}

	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DangerousGoodsExtendedType_Decode(V2xFac_DangerousGoodsExtendedType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;
	int i1;
	asn1SccSint nStringLength;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.emergencyActionCode = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.phoneNumber = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.companyName = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE;
	        if (ret) {
	            /*Decode dangerousGoodsType */
	            ret = V2xFac_DangerousGoodsBasicType_Decode((&(pVal->dangerousGoodsType)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode unNumber */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->unNumber)), 0, 9999);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_UNNUMBER;
	                if (ret) {
	                    /*Decode elevatedTemperature */
	                    ret = BitStream_ReadBit(pBitStrm, (&(pVal->elevatedTemperature)));
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_ELEVATEDTEMPERATURE;
	                    if (ret) {
	                        /*Decode tunnelsRestricted */
	                        ret = BitStream_ReadBit(pBitStrm, (&(pVal->tunnelsRestricted)));
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_TUNNELSRESTRICTED;
	                        if (ret) {
	                            /*Decode limitedQuantity */
	                            ret = BitStream_ReadBit(pBitStrm, (&(pVal->limitedQuantity)));
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_LIMITEDQUANTITY;
	                            if (ret) {
	                                /*Decode emergencyActionCode */
	                                if (pVal->exist.emergencyActionCode) {
	                                	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 24);
	                                		
	                                	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                	{
	                                		asn1SccSint charValue=0;
	                                		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
	                                		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_EMERGENCYACTIONCODE;
	                                		pVal->emergencyActionCode[i1] = (char)charValue;
	                                	}
	                                	pVal->emergencyActionCode[nStringLength] = 0x0;
	                                }
	                                if (ret) {
	                                    /*Decode phoneNumber */
	                                    if (pVal->exist.phoneNumber) {
	                                    	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 24);
	                                    		
	                                    	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                    	{
	                                    		asn1SccSint charValue=0;
	                                    		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
	                                    		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_PHONENUMBER;
	                                    		pVal->phoneNumber[i1] = (char)charValue;
	                                    	}
	                                    	pVal->phoneNumber[nStringLength] = 0x0;
	                                    }
	                                    if (ret) {
	                                        /*Decode companyName */
	                                        if (pVal->exist.companyName) {
	                                        	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 24);
	                                        		
	                                        	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	                                        	{
	                                        		asn1SccSint charValue=0;
	                                        		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
	                                        		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DANGEROUSGOODSEXTENDEDTYPE_COMPANYNAME;
	                                        		pVal->companyName[i1] = (char)charValue;
	                                        	}
	                                        	pVal->companyName[nStringLength] = 0x0;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_DangerousGoodsExtendedType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpecialTransportTypeType_Initialize(V2xFac_SpecialTransportTypeType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_SpecialTransportTypeType_IsConstraintValid(const V2xFac_SpecialTransportTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_SpecialTransportTypeType_Encode(const V2xFac_SpecialTransportTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpecialTransportTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 4);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpecialTransportTypeType_Decode(V2xFac_SpecialTransportTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SPECIALTRANSPORTTYPETYPE;

	return ret  && V2xFac_SpecialTransportTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LightBarSirenInUseType_Initialize(V2xFac_LightBarSirenInUseType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_LightBarSirenInUseType_IsConstraintValid(const V2xFac_LightBarSirenInUseType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_LightBarSirenInUseType_Encode(const V2xFac_LightBarSirenInUseType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LightBarSirenInUseType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 2);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LightBarSirenInUseType_Decode(V2xFac_LightBarSirenInUseType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LIGHTBARSIRENINUSETYPE;

	return ret  && V2xFac_LightBarSirenInUseType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HeightLonCarrType_Initialize(V2xFac_HeightLonCarrType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_HeightLonCarrType_IsConstraintValid(const V2xFac_HeightLonCarrType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 100UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_HEIGHTLONCARRTYPE; 

	return ret;
}

flag V2xFac_HeightLonCarrType_Encode(const V2xFac_HeightLonCarrType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HeightLonCarrType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 100);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HeightLonCarrType_Decode(V2xFac_HeightLonCarrType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 100);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HEIGHTLONCARRTYPE;

	return ret  && V2xFac_HeightLonCarrType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PosLonCarrType_Initialize(V2xFac_PosLonCarrType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_PosLonCarrType_IsConstraintValid(const V2xFac_PosLonCarrType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 127UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSLONCARRTYPE; 

	return ret;
}

flag V2xFac_PosLonCarrType_Encode(const V2xFac_PosLonCarrType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PosLonCarrType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PosLonCarrType_Decode(V2xFac_PosLonCarrType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSLONCARRTYPE;

	return ret  && V2xFac_PosLonCarrType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PosPillarType_Initialize(V2xFac_PosPillarType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_PosPillarType_IsConstraintValid(const V2xFac_PosPillarType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 30UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSPILLARTYPE; 

	return ret;
}

flag V2xFac_PosPillarType_Encode(const V2xFac_PosPillarType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PosPillarType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 30);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PosPillarType_Decode(V2xFac_PosPillarType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 30);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSPILLARTYPE;

	return ret  && V2xFac_PosPillarType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PositionOfPillarsType_Initialize(V2xFac_PositionOfPillarsType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    V2xFac_PosPillarType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_PositionOfPillarsType_IsConstraintValid(const V2xFac_PositionOfPillarsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSITIONOFPILLARSTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_PosPillarType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_PositionOfPillarsType_Encode(const V2xFac_PositionOfPillarsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_PositionOfPillarsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_PosPillarType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PositionOfPillarsType_Decode(V2xFac_PositionOfPillarsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSITIONOFPILLARSTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_PosPillarType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_PositionOfPillarsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PosCentMassType_Initialize(V2xFac_PosCentMassType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_PosCentMassType_IsConstraintValid(const V2xFac_PosCentMassType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 63UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSCENTMASSTYPE; 

	return ret;
}

flag V2xFac_PosCentMassType_Encode(const V2xFac_PosCentMassType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PosCentMassType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 63);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PosCentMassType_Decode(V2xFac_PosCentMassType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 63);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSCENTMASSTYPE;

	return ret  && V2xFac_PosCentMassType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RequestResponseIndicationType_Initialize(V2xFac_RequestResponseIndicationType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_REQUEST;
}

flag V2xFac_RequestResponseIndicationType_IsConstraintValid(const V2xFac_RequestResponseIndicationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_REQUEST)) || (((*(pVal)) == v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_RESPONSE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_REQUESTRESPONSEINDICATIONTYPE; 

	return ret;
}

flag V2xFac_RequestResponseIndicationType_Encode(const V2xFac_RequestResponseIndicationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RequestResponseIndicationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_REQUEST:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_RESPONSE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_REQUESTRESPONSEINDICATIONTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RequestResponseIndicationType_Decode(V2xFac_RequestResponseIndicationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_REQUESTRESPONSEINDICATIONTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_REQUEST;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_RESPONSE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_REQUESTRESPONSEINDICATIONTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_REQUEST_RESPONSE_INDICATION_TYPE_REQUEST;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_RequestResponseIndicationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpeedLimitType_Initialize(V2xFac_SpeedLimitType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_SpeedLimitType_IsConstraintValid(const V2xFac_SpeedLimitType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 255UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SPEEDLIMITTYPE; 

	return ret;
}

flag V2xFac_SpeedLimitType_Encode(const V2xFac_SpeedLimitType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpeedLimitType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpeedLimitType_Decode(V2xFac_SpeedLimitType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SPEEDLIMITTYPE;

	return ret  && V2xFac_SpeedLimitType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_StationarySinceType_Initialize(V2xFac_StationarySinceType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_STATIONARYSINCE_LESS_THAN_1_MINUTE;
}

flag V2xFac_StationarySinceType_IsConstraintValid(const V2xFac_StationarySinceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == v2XFAC_STATIONARYSINCE_LESS_THAN_1_MINUTE)) || (((*(pVal)) == v2XFAC_STATIONARYSINCE_LESS_THAN_2_MINUTES)))) || (((*(pVal)) == v2XFAC_STATIONARYSINCE_LESS_THAN_15_MINUTES)))) || (((*(pVal)) == v2XFAC_STATIONARYSINCE_EQUAL_OR_GREATER_15_MINUTES)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STATIONARYSINCETYPE; 

	return ret;
}

flag V2xFac_StationarySinceType_Encode(const V2xFac_StationarySinceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_StationarySinceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_STATIONARYSINCE_LESS_THAN_1_MINUTE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case v2XFAC_STATIONARYSINCE_LESS_THAN_2_MINUTES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case v2XFAC_STATIONARYSINCE_LESS_THAN_15_MINUTES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case v2XFAC_STATIONARYSINCE_EQUAL_OR_GREATER_15_MINUTES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_STATIONARYSINCETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_StationarySinceType_Decode(V2xFac_StationarySinceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYSINCETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_STATIONARYSINCE_LESS_THAN_1_MINUTE;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_STATIONARYSINCE_LESS_THAN_2_MINUTES;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_STATIONARYSINCE_LESS_THAN_15_MINUTES;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_STATIONARYSINCE_EQUAL_OR_GREATER_15_MINUTES;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_STATIONARYSINCETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_STATIONARYSINCE_LESS_THAN_1_MINUTE;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_StationarySinceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TemperatureType_Initialize(V2xFac_TemperatureType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_TemperatureType_IsConstraintValid(const V2xFac_TemperatureType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-60LL <= (*(pVal))) && ((*(pVal)) <= 67LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TEMPERATURETYPE; 

	return ret;
}

flag V2xFac_TemperatureType_Encode(const V2xFac_TemperatureType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TemperatureType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -60, 67);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TemperatureType_Decode(V2xFac_TemperatureType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -60, 67);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TEMPERATURETYPE;

	return ret  && V2xFac_TemperatureType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TrafficRuleType_Initialize(V2xFac_TrafficRuleType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_TRAFFICRULE_NO_PASSING;
}

flag V2xFac_TrafficRuleType_IsConstraintValid(const V2xFac_TrafficRuleType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == v2XFAC_TRAFFICRULE_NO_PASSING)) || (((*(pVal)) == v2XFAC_TRAFFICRULE_NO_PASSING_FOR_TRUCKS)))) || (((*(pVal)) == v2XFAC_TRAFFICRULE_PASS_TO_RIGHT)))) || (((*(pVal)) == v2XFAC_TRAFFICRULE_PASS_TO_LEFT)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TRAFFICRULETYPE; 

	return ret;
}

flag V2xFac_TrafficRuleType_Encode(const V2xFac_TrafficRuleType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TrafficRuleType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_TRAFFICRULE_NO_PASSING:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case v2XFAC_TRAFFICRULE_NO_PASSING_FOR_TRUCKS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case v2XFAC_TRAFFICRULE_PASS_TO_RIGHT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case v2XFAC_TRAFFICRULE_PASS_TO_LEFT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_TRAFFICRULETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TrafficRuleType_Decode(V2xFac_TrafficRuleType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TRAFFICRULETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_TRAFFICRULE_NO_PASSING;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_TRAFFICRULE_NO_PASSING_FOR_TRUCKS;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_TRAFFICRULE_PASS_TO_RIGHT;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_TRAFFICRULE_PASS_TO_LEFT;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_TRAFFICRULETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_TRAFFICRULE_NO_PASSING;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_TrafficRuleType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_WheelBaseVehicleType_Initialize(V2xFac_WheelBaseVehicleType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_WheelBaseVehicleType_IsConstraintValid(const V2xFac_WheelBaseVehicleType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 127UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_WHEELBASEVEHICLETYPE; 

	return ret;
}

flag V2xFac_WheelBaseVehicleType_Encode(const V2xFac_WheelBaseVehicleType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_WheelBaseVehicleType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_WheelBaseVehicleType_Decode(V2xFac_WheelBaseVehicleType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_WHEELBASEVEHICLETYPE;

	return ret  && V2xFac_WheelBaseVehicleType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TurningRadiusType_Initialize(V2xFac_TurningRadiusType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_TurningRadiusType_IsConstraintValid(const V2xFac_TurningRadiusType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 255UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TURNINGRADIUSTYPE; 

	return ret;
}

flag V2xFac_TurningRadiusType_Encode(const V2xFac_TurningRadiusType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TurningRadiusType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TurningRadiusType_Decode(V2xFac_TurningRadiusType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TURNINGRADIUSTYPE;

	return ret  && V2xFac_TurningRadiusType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PosFrontAxType_Initialize(V2xFac_PosFrontAxType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_PosFrontAxType_IsConstraintValid(const V2xFac_PosFrontAxType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 20UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSFRONTAXTYPE; 

	return ret;
}

flag V2xFac_PosFrontAxType_Encode(const V2xFac_PosFrontAxType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PosFrontAxType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 20);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PosFrontAxType_Decode(V2xFac_PosFrontAxType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 20);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSFRONTAXTYPE;

	return ret  && V2xFac_PosFrontAxType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PositionOfOccupantsType_Initialize(V2xFac_PositionOfOccupantsType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 24/8);


}

flag V2xFac_PositionOfOccupantsType_IsConstraintValid(const V2xFac_PositionOfOccupantsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_PositionOfOccupantsType_Encode(const V2xFac_PositionOfOccupantsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PositionOfOccupantsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 20);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PositionOfOccupantsType_Decode(V2xFac_PositionOfOccupantsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 20);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSITIONOFOCCUPANTSTYPE;

	return ret  && V2xFac_PositionOfOccupantsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_PositioningSolutionTypeType_Initialize(V2xFac_PositioningSolutionTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_NO_POSITIONING_SOLUTION;
}

flag V2xFac_PositioningSolutionTypeType_IsConstraintValid(const V2xFac_PositioningSolutionTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_NO_POSITIONING_SOLUTION)) || (((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSS)))) || (((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSS)))) || (((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSSPLUSDR)))) || (((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSSPLUSDR)))) || (((*(pVal)) == v2XFAC_POSITIONINGSOLUTIONTYPE_DR)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_POSITIONINGSOLUTIONTYPETYPE; 

	return ret;
}

flag V2xFac_PositioningSolutionTypeType_Encode(const V2xFac_PositioningSolutionTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PositioningSolutionTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_NO_POSITIONING_SOLUTION:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSSPLUSDR:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSSPLUSDR:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case v2XFAC_POSITIONINGSOLUTIONTYPE_DR:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_POSITIONINGSOLUTIONTYPETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PositioningSolutionTypeType_Decode(V2xFac_PositioningSolutionTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_POSITIONINGSOLUTIONTYPETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_NO_POSITIONING_SOLUTION;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSS;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSS;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_SGNSSPLUSDR;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_DGNSSPLUSDR;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_DR;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_POSITIONINGSOLUTIONTYPETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_POSITIONINGSOLUTIONTYPE_NO_POSITIONING_SOLUTION;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_PositioningSolutionTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_WMInumberType_Initialize(V2xFac_WMInumberType val)
{
	(void)val;


	memset(val, 0x0, 4);

}

flag V2xFac_WMInumberType_IsConstraintValid(const V2xFac_WMInumberType val, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1 <= strlen(val)) && (strlen(val) <= 3));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_WMINUMBERTYPE; 

	return ret;
}

flag V2xFac_WMInumberType_Encode(const V2xFac_WMInumberType val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	asn1SccSint nStringLength;
	ret = bCheckConstraints ? V2xFac_WMInumberType_IsConstraintValid(val, pErrCode) : TRUE ;
	if (ret) {
	    nStringLength = strlen(val);
	    /*ret = nStringLength >= 1 && nStringLength <= 3;*/
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, nStringLength, 1, 3);
	    	
	    for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, val[i1], 0, 127);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_WMInumberType_Decode(V2xFac_WMInumberType val, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nStringLength;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nStringLength, 1, 3);
		
	for(i1=0; (i1 < (int)nStringLength) && ret; i1++) 
	{
		asn1SccSint charValue=0;
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_WMINUMBERTYPE;
		val[i1] = (char)charValue;
	}
	val[nStringLength] = 0x0;

	return ret  && V2xFac_WMInumberType_IsConstraintValid(val, pErrCode);
}



void V2xFac_VDSType_Initialize(V2xFac_VDSType val)
{
	(void)val;


	memset(val, 0x0, 7);

}

flag V2xFac_VDSType_IsConstraintValid(const V2xFac_VDSType val, int* pErrCode)
{
    flag ret = TRUE;
    ret = (strlen(val) == 6);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VDSTYPE; 

	return ret;
}

flag V2xFac_VDSType_Encode(const V2xFac_VDSType val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_VDSType_IsConstraintValid(val, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, val[i1], 0, 127);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VDSType_Decode(V2xFac_VDSType val, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		asn1SccSint charValue=0;
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VDSTYPE;
		val[i1] = (char)charValue;
	}
	val[6] = 0x0;

	return ret  && V2xFac_VDSType_IsConstraintValid(val, pErrCode);
}



void V2xFac_VehicleIdentificationType_Initialize(V2xFac_VehicleIdentificationType* pVal)
{
	(void)pVal;



	/*set wmiNumber */
	pVal->exist.wmiNumber = 1;
	V2xFac_WMInumberType_Initialize(pVal->wmiNumber);
	/*set vds */
	pVal->exist.vds = 1;
	V2xFac_VDSType_Initialize(pVal->vds);
}

flag V2xFac_VehicleIdentificationType_IsConstraintValid(const V2xFac_VehicleIdentificationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.wmiNumber) {
    	ret = V2xFac_WMInumberType_IsConstraintValid(pVal->wmiNumber, pErrCode);
    }
    if (ret) {
        if (pVal->exist.vds) {
        	ret = V2xFac_VDSType_IsConstraintValid(pVal->vds, pErrCode);
        }
    }

	return ret;
}

flag V2xFac_VehicleIdentificationType_Encode(const V2xFac_VehicleIdentificationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleIdentificationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.wmiNumber);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.vds);
	        if (ret) {
	            /*Encode wmiNumber */
	            if (pVal->exist.wmiNumber) {
	            	ret = V2xFac_WMInumberType_Encode(pVal->wmiNumber, pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode vds */
	                if (pVal->exist.vds) {
	                	ret = V2xFac_VDSType_Encode(pVal->vds, pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleIdentificationType_Decode(V2xFac_VehicleIdentificationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.wmiNumber = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEIDENTIFICATIONTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.vds = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEIDENTIFICATIONTYPE;
	    if (ret) {
	        /*Decode wmiNumber */
	        if (pVal->exist.wmiNumber) {
	        	ret = V2xFac_WMInumberType_Decode(pVal->wmiNumber, pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode vds */
	            if (pVal->exist.vds) {
	            	ret = V2xFac_VDSType_Decode(pVal->vds, pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && V2xFac_VehicleIdentificationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EnergyStorageTypeType_Initialize(V2xFac_EnergyStorageTypeType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_EnergyStorageTypeType_IsConstraintValid(const V2xFac_EnergyStorageTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_EnergyStorageTypeType_Encode(const V2xFac_EnergyStorageTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EnergyStorageTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EnergyStorageTypeType_Decode(V2xFac_EnergyStorageTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ENERGYSTORAGETYPETYPE;

	return ret  && V2xFac_EnergyStorageTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleLengthValueType_Initialize(V2xFac_VehicleLengthValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_VehicleLengthValueType_IsConstraintValid(const V2xFac_VehicleLengthValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 1023UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLELENGTHVALUETYPE; 

	return ret;
}

flag V2xFac_VehicleLengthValueType_Encode(const V2xFac_VehicleLengthValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleLengthValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 1023);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleLengthValueType_Decode(V2xFac_VehicleLengthValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 1023);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLELENGTHVALUETYPE;

	return ret  && V2xFac_VehicleLengthValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleLengthConfidenceIndicationType_Initialize(V2xFac_VehicleLengthConfidenceIndicationType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_NOTRAILERPRESENT;
}

flag V2xFac_VehicleLengthConfidenceIndicationType_IsConstraintValid(const V2xFac_VehicleLengthConfidenceIndicationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((*(pVal)) == v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_NOTRAILERPRESENT)) || (((*(pVal)) == v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHKNOWNLENGTH)))) || (((*(pVal)) == v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHUNKNOWNLENGTH)))) || (((*(pVal)) == v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENCEISUNKNOWN)))) || (((*(pVal)) == v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLELENGTHCONFIDENCEINDICATIONTYPE; 

	return ret;
}

flag V2xFac_VehicleLengthConfidenceIndicationType_Encode(const V2xFac_VehicleLengthConfidenceIndicationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleLengthConfidenceIndicationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_NOTRAILERPRESENT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHKNOWNLENGTH:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHUNKNOWNLENGTH:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENCEISUNKNOWN:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_VEHICLELENGTHCONFIDENCEINDICATIONTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleLengthConfidenceIndicationType_Decode(V2xFac_VehicleLengthConfidenceIndicationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLELENGTHCONFIDENCEINDICATIONTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_NOTRAILERPRESENT;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHKNOWNLENGTH;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENTWITHUNKNOWNLENGTH;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_TRAILERPRESENCEISUNKNOWN;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_VEHICLELENGTHCONFIDENCEINDICATIONTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_VEHICLELENGTHCONFIDENCEINDICATION_NOTRAILERPRESENT;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_VehicleLengthConfidenceIndicationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleLengthType_Initialize(V2xFac_VehicleLengthType* pVal)
{
	(void)pVal;



	/*set vehicleLengthValue */
	V2xFac_VehicleLengthValueType_Initialize((&(pVal->vehicleLengthValue)));
	/*set vehicleLengthConfidenceIndication */
	V2xFac_VehicleLengthConfidenceIndicationType_Initialize((&(pVal->vehicleLengthConfidenceIndication)));
}

flag V2xFac_VehicleLengthType_IsConstraintValid(const V2xFac_VehicleLengthType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_VehicleLengthValueType_IsConstraintValid((&(pVal->vehicleLengthValue)), pErrCode);
    if (ret) {
        ret = V2xFac_VehicleLengthConfidenceIndicationType_IsConstraintValid((&(pVal->vehicleLengthConfidenceIndication)), pErrCode);
    }

	return ret;
}

flag V2xFac_VehicleLengthType_Encode(const V2xFac_VehicleLengthType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleLengthType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vehicleLengthValue */
	    ret = V2xFac_VehicleLengthValueType_Encode((&(pVal->vehicleLengthValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode vehicleLengthConfidenceIndication */
	        ret = V2xFac_VehicleLengthConfidenceIndicationType_Encode((&(pVal->vehicleLengthConfidenceIndication)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleLengthType_Decode(V2xFac_VehicleLengthType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode vehicleLengthValue */
	ret = V2xFac_VehicleLengthValueType_Decode((&(pVal->vehicleLengthValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode vehicleLengthConfidenceIndication */
	    ret = V2xFac_VehicleLengthConfidenceIndicationType_Decode((&(pVal->vehicleLengthConfidenceIndication)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_VehicleLengthType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleWidthType_Initialize(V2xFac_VehicleWidthType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_VehicleWidthType_IsConstraintValid(const V2xFac_VehicleWidthType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    // ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 62UL));
	ret = 1;
    // *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLEWIDTHTYPE; 
	*pErrCode = 0;
	return ret;
}

flag V2xFac_VehicleWidthType_Encode(const V2xFac_VehicleWidthType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleWidthType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 62);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleWidthType_Decode(V2xFac_VehicleWidthType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 62);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEWIDTHTYPE;

	return ret  && V2xFac_VehicleWidthType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EmergencyPriorityType_Initialize(V2xFac_EmergencyPriorityType* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 8/8);


}

flag V2xFac_EmergencyPriorityType_IsConstraintValid(const V2xFac_EmergencyPriorityType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag V2xFac_EmergencyPriorityType_Encode(const V2xFac_EmergencyPriorityType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EmergencyPriorityType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 2);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EmergencyPriorityType_Decode(V2xFac_EmergencyPriorityType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBits(pBitStrm, pVal->arr, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EMERGENCYPRIORITYTYPE;

	return ret  && V2xFac_EmergencyPriorityType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_InformationQualityType_Initialize(V2xFac_InformationQualityType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_InformationQualityType_IsConstraintValid(const V2xFac_InformationQualityType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 7UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_INFORMATIONQUALITYTYPE; 

	return ret;
}

flag V2xFac_InformationQualityType_Encode(const V2xFac_InformationQualityType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_InformationQualityType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 7);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_InformationQualityType_Decode(V2xFac_InformationQualityType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_INFORMATIONQUALITYTYPE;

	return ret  && V2xFac_InformationQualityType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EventPointType_Initialize(V2xFac_EventPointType* pVal)
{
	(void)pVal;



	/*set eventPosition */
	V2xFac_DeltaReferencePositionType_Initialize((&(pVal->eventPosition)));
	/*set eventDeltaTime */
	pVal->exist.eventDeltaTime = 1;
	V2xFac_PathDeltaTimeType_Initialize((&(pVal->eventDeltaTime)));
	/*set informationQuality */
	V2xFac_InformationQualityType_Initialize((&(pVal->informationQuality)));
}

flag V2xFac_EventPointType_IsConstraintValid(const V2xFac_EventPointType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_DeltaReferencePositionType_IsConstraintValid((&(pVal->eventPosition)), pErrCode);
    if (ret) {
        if (pVal->exist.eventDeltaTime) {
        	ret = V2xFac_PathDeltaTimeType_IsConstraintValid((&(pVal->eventDeltaTime)), pErrCode);
        }
        if (ret) {
            ret = V2xFac_InformationQualityType_IsConstraintValid((&(pVal->informationQuality)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_EventPointType_Encode(const V2xFac_EventPointType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EventPointType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.eventDeltaTime);
	    if (ret) {
	        /*Encode eventPosition */
	        ret = V2xFac_DeltaReferencePositionType_Encode((&(pVal->eventPosition)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode eventDeltaTime */
	            if (pVal->exist.eventDeltaTime) {
	            	ret = V2xFac_PathDeltaTimeType_Encode((&(pVal->eventDeltaTime)), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode informationQuality */
	                ret = V2xFac_InformationQualityType_Encode((&(pVal->informationQuality)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EventPointType_Decode(V2xFac_EventPointType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.eventDeltaTime = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EVENTPOINTTYPE;
	if (ret) {
	    /*Decode eventPosition */
	    ret = V2xFac_DeltaReferencePositionType_Decode((&(pVal->eventPosition)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode eventDeltaTime */
	        if (pVal->exist.eventDeltaTime) {
	        	ret = V2xFac_PathDeltaTimeType_Decode((&(pVal->eventDeltaTime)), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode informationQuality */
	            ret = V2xFac_InformationQualityType_Decode((&(pVal->informationQuality)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && V2xFac_EventPointType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_EventHistoryType_Initialize(V2xFac_EventHistoryType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 23) {
	    V2xFac_EventPointType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_EventHistoryType_IsConstraintValid(const V2xFac_EventHistoryType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 23));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_EVENTHISTORYTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_EventPointType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_EventHistoryType_Encode(const V2xFac_EventHistoryType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_EventHistoryType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 23);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_EventPointType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EventHistoryType_Decode(V2xFac_EventHistoryType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 23);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EVENTHISTORYTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_EventPointType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_EventHistoryType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RoadTypeType_Initialize(V2xFac_RoadTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_ROADTYPE_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES;
}

flag V2xFac_RoadTypeType_IsConstraintValid(const V2xFac_RoadTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == v2XFAC_ROADTYPE_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES)) || (((*(pVal)) == v2XFAC_ROADTYPE_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES)))) || (((*(pVal)) == v2XFAC_ROADTYPE_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES)))) || (((*(pVal)) == v2XFAC_ROADTYPE_ONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_ROADTYPETYPE; 

	return ret;
}

flag V2xFac_RoadTypeType_Encode(const V2xFac_RoadTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RoadTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_ROADTYPE_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case v2XFAC_ROADTYPE_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case v2XFAC_ROADTYPE_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case v2XFAC_ROADTYPE_ONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_ROADTYPETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RoadTypeType_Decode(V2xFac_RoadTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADTYPETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_ROADTYPE_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_ROADTYPE_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_ROADTYPE_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_ROADTYPE_ONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_ROADTYPETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_ROADTYPE_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_RoadTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SteeringWheelAngleValueType_Initialize(V2xFac_SteeringWheelAngleValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SteeringWheelAngleValueType_IsConstraintValid(const V2xFac_SteeringWheelAngleValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-511LL <= (*(pVal))) && ((*(pVal)) <= 512LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STEERINGWHEELANGLEVALUETYPE; 

	return ret;
}

flag V2xFac_SteeringWheelAngleValueType_Encode(const V2xFac_SteeringWheelAngleValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SteeringWheelAngleValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -511, 512);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SteeringWheelAngleValueType_Decode(V2xFac_SteeringWheelAngleValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -511, 512);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STEERINGWHEELANGLEVALUETYPE;

	return ret  && V2xFac_SteeringWheelAngleValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SteeringWheelAngleConfidenceType_Initialize(V2xFac_SteeringWheelAngleConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_SteeringWheelAngleConfidenceType_IsConstraintValid(const V2xFac_SteeringWheelAngleConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 127UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_STEERINGWHEELANGLECONFIDENCETYPE; 

	return ret;
}

flag V2xFac_SteeringWheelAngleConfidenceType_Encode(const V2xFac_SteeringWheelAngleConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SteeringWheelAngleConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SteeringWheelAngleConfidenceType_Decode(V2xFac_SteeringWheelAngleConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STEERINGWHEELANGLECONFIDENCETYPE;

	return ret  && V2xFac_SteeringWheelAngleConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SteeringWheelAngleType_Initialize(V2xFac_SteeringWheelAngleType* pVal)
{
	(void)pVal;



	/*set steeringWheelAngleValue */
	V2xFac_SteeringWheelAngleValueType_Initialize((&(pVal->steeringWheelAngleValue)));
	/*set steeringWheelAngleConfidence */
	V2xFac_SteeringWheelAngleConfidenceType_Initialize((&(pVal->steeringWheelAngleConfidence)));
}

flag V2xFac_SteeringWheelAngleType_IsConstraintValid(const V2xFac_SteeringWheelAngleType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_SteeringWheelAngleValueType_IsConstraintValid((&(pVal->steeringWheelAngleValue)), pErrCode);
    if (ret) {
        ret = V2xFac_SteeringWheelAngleConfidenceType_IsConstraintValid((&(pVal->steeringWheelAngleConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_SteeringWheelAngleType_Encode(const V2xFac_SteeringWheelAngleType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SteeringWheelAngleType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode steeringWheelAngleValue */
	    ret = V2xFac_SteeringWheelAngleValueType_Encode((&(pVal->steeringWheelAngleValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode steeringWheelAngleConfidence */
	        ret = V2xFac_SteeringWheelAngleConfidenceType_Encode((&(pVal->steeringWheelAngleConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SteeringWheelAngleType_Decode(V2xFac_SteeringWheelAngleType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode steeringWheelAngleValue */
	ret = V2xFac_SteeringWheelAngleValueType_Decode((&(pVal->steeringWheelAngleValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode steeringWheelAngleConfidence */
	    ret = V2xFac_SteeringWheelAngleConfidenceType_Decode((&(pVal->steeringWheelAngleConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_SteeringWheelAngleType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TimestampItsType_Initialize(V2xFac_TimestampItsType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_TimestampItsType_IsConstraintValid(const V2xFac_TimestampItsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4398046511103UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TIMESTAMPITSTYPE; 

	return ret;
}

flag V2xFac_TimestampItsType_Encode(const V2xFac_TimestampItsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TimestampItsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4398046511103LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TimestampItsType_Decode(V2xFac_TimestampItsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4398046511103LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TIMESTAMPITSTYPE;

	return ret  && V2xFac_TimestampItsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_VehicleRoleType_Initialize(V2xFac_VehicleRoleType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_VEHICLEROLE_DEFAULT;
}

flag V2xFac_VehicleRoleType_IsConstraintValid(const V2xFac_VehicleRoleType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((((((((((((((((*(pVal)) == v2XFAC_VEHICLEROLE_DEFAULT)) || (((*(pVal)) == v2XFAC_VEHICLEROLE_PUBLIC_TRANSPORT)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_SPECIAL_TRANSPORT)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_DANGEROUS_GOODS)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_ROAD_WORK)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_RESCUE)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_EMERGENCY)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_SAFETY_CAR)))) || (((*(pVal)) == v2XFAC_VEHICLEROLEAGRICULTURAL)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_COMMERCIAL)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_MILITARY)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_ROAD_OPERATOR)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_TAXI)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_RESERVED_1)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_RESERVED_2)))) || (((*(pVal)) == v2XFAC_VEHICLEROLE_RESERVED_3)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VEHICLEROLETYPE; 

	return ret;
}

flag V2xFac_VehicleRoleType_Encode(const V2xFac_VehicleRoleType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_VehicleRoleType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_VEHICLEROLE_DEFAULT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_PUBLIC_TRANSPORT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_SPECIAL_TRANSPORT:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_DANGEROUS_GOODS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_ROAD_WORK:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_RESCUE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_EMERGENCY:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_SAFETY_CAR:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLEAGRICULTURAL:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_COMMERCIAL:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_MILITARY:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_ROAD_OPERATOR:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_TAXI:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_RESERVED_1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_RESERVED_2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
	        	break;
	        case v2XFAC_VEHICLEROLE_RESERVED_3:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_VEHICLEROLETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_VehicleRoleType_Decode(V2xFac_VehicleRoleType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VEHICLEROLETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_DEFAULT;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_PUBLIC_TRANSPORT;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_SPECIAL_TRANSPORT;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_DANGEROUS_GOODS;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_ROAD_WORK;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_RESCUE;
	                break;
	            case 6: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_EMERGENCY;
	                break;
	            case 7: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_SAFETY_CAR;
	                break;
	            case 8: 
	                (*(pVal)) = v2XFAC_VEHICLEROLEAGRICULTURAL;
	                break;
	            case 9: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_COMMERCIAL;
	                break;
	            case 10: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_MILITARY;
	                break;
	            case 11: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_ROAD_OPERATOR;
	                break;
	            case 12: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_TAXI;
	                break;
	            case 13: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_RESERVED_1;
	                break;
	            case 14: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_RESERVED_2;
	                break;
	            case 15: 
	                (*(pVal)) = v2XFAC_VEHICLEROLE_RESERVED_3;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_VEHICLEROLETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_VEHICLEROLE_DEFAULT;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_VehicleRoleType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_YawRateValueType_Initialize(V2xFac_YawRateValueType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_YawRateValueType_IsConstraintValid(const V2xFac_YawRateValueType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-32766LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_YAWRATEVALUETYPE; 

	return ret;
}

flag V2xFac_YawRateValueType_Encode(const V2xFac_YawRateValueType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_YawRateValueType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32766, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_YawRateValueType_Decode(V2xFac_YawRateValueType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32766, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_YAWRATEVALUETYPE;

	return ret  && V2xFac_YawRateValueType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_YawRateConfidenceType_Initialize(V2xFac_YawRateConfidenceType* pVal)
{
	(void)pVal;


	(*(pVal)) = yAWRATECONFIDENCE_DEGSEC_000_01;
}

flag V2xFac_YawRateConfidenceType_IsConstraintValid(const V2xFac_YawRateConfidenceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_000_01)) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_000_05)))) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_000_10)))) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_001_00)))) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_005_00)))) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_010_00)))) || (((*(pVal)) == yAWRATECONFIDENCE_DEGSEC_100_00)))) || (((*(pVal)) == yAWRATECONFIDENCE_OUTOFRANGE)))) || (((*(pVal)) == yAWRATECONFIDENCE_UNAVAILABLE)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_YAWRATECONFIDENCETYPE; 

	return ret;
}

flag V2xFac_YawRateConfidenceType_Encode(const V2xFac_YawRateConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_YawRateConfidenceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case yAWRATECONFIDENCE_DEGSEC_000_01:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_000_05:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_000_10:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_001_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_005_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_010_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_DEGSEC_100_00:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_OUTOFRANGE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 8);
	        	break;
	        case yAWRATECONFIDENCE_UNAVAILABLE:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 8);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_YAWRATECONFIDENCETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_YawRateConfidenceType_Decode(V2xFac_YawRateConfidenceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 8);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_YAWRATECONFIDENCETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_000_01;
	                break;
	            case 1: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_000_05;
	                break;
	            case 2: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_000_10;
	                break;
	            case 3: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_001_00;
	                break;
	            case 4: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_005_00;
	                break;
	            case 5: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_010_00;
	                break;
	            case 6: 
	                (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_100_00;
	                break;
	            case 7: 
	                (*(pVal)) = yAWRATECONFIDENCE_OUTOFRANGE;
	                break;
	            case 8: 
	                (*(pVal)) = yAWRATECONFIDENCE_UNAVAILABLE;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_YAWRATECONFIDENCETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = yAWRATECONFIDENCE_DEGSEC_000_01;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_YawRateConfidenceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_YawRateType_Initialize(V2xFac_YawRateType* pVal)
{
	(void)pVal;



	/*set yawRateValue */
	V2xFac_YawRateValueType_Initialize((&(pVal->yawRateValue)));
	/*set yawRateConfidence */
	V2xFac_YawRateConfidenceType_Initialize((&(pVal->yawRateConfidence)));
}

flag V2xFac_YawRateType_IsConstraintValid(const V2xFac_YawRateType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_YawRateValueType_IsConstraintValid((&(pVal->yawRateValue)), pErrCode);
    if (ret) {
        ret = V2xFac_YawRateConfidenceType_IsConstraintValid((&(pVal->yawRateConfidence)), pErrCode);
    }

	return ret;
}

flag V2xFac_YawRateType_Encode(const V2xFac_YawRateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_YawRateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yawRateValue */
	    ret = V2xFac_YawRateValueType_Encode((&(pVal->yawRateValue)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode yawRateConfidence */
	        ret = V2xFac_YawRateConfidenceType_Encode((&(pVal->yawRateConfidence)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_YawRateType_Decode(V2xFac_YawRateType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode yawRateValue */
	ret = V2xFac_YawRateValueType_Decode((&(pVal->yawRateValue)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode yawRateConfidence */
	    ret = V2xFac_YawRateConfidenceType_Decode((&(pVal->yawRateConfidence)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_YawRateType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ProtectedZoneTypeType_Initialize(V2xFac_ProtectedZoneTypeType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_PROTECTEDZONETYPE_CEN_DSRC_TOLLING;
}

flag V2xFac_ProtectedZoneTypeType_IsConstraintValid(const V2xFac_ProtectedZoneTypeType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) == v2XFAC_PROTECTEDZONETYPE_CEN_DSRC_TOLLING);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PROTECTEDZONETYPETYPE; 

	return ret;
}

flag V2xFac_ProtectedZoneTypeType_Encode(const V2xFac_ProtectedZoneTypeType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ProtectedZoneTypeType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_PROTECTEDZONETYPE_CEN_DSRC_TOLLING:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_PROTECTEDZONETYPETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ProtectedZoneTypeType_Decode(V2xFac_ProtectedZoneTypeType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDZONETYPETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_PROTECTEDZONETYPE_CEN_DSRC_TOLLING;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_PROTECTEDZONETYPETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_PROTECTEDZONETYPE_CEN_DSRC_TOLLING;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_ProtectedZoneTypeType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RelevanceDistanceType_Initialize(V2xFac_RelevanceDistanceType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_50_M;
}

flag V2xFac_RelevanceDistanceType_IsConstraintValid(const V2xFac_RelevanceDistanceType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_50_M)) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_100_M)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_200_M)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_500_M)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_1000_M)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_5_KM)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_LESS_THAN_10_KM)))) || (((*(pVal)) == v2XFAC_RELEVANCEDISTANCE_OVER_10_KM)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_RELEVANCEDISTANCETYPE; 

	return ret;
}

flag V2xFac_RelevanceDistanceType_Encode(const V2xFac_RelevanceDistanceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RelevanceDistanceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_50_M:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_100_M:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_200_M:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_500_M:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_1000_M:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_5_KM:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_LESS_THAN_10_KM:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case v2XFAC_RELEVANCEDISTANCE_OVER_10_KM:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_RELEVANCEDISTANCETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RelevanceDistanceType_Decode(V2xFac_RelevanceDistanceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_RELEVANCEDISTANCETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_50_M;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_100_M;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_200_M;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_500_M;
	                break;
	            case 4: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_1000_M;
	                break;
	            case 5: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_5_KM;
	                break;
	            case 6: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_10_KM;
	                break;
	            case 7: 
	                (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_OVER_10_KM;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_RELEVANCEDISTANCETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_RELEVANCEDISTANCE_LESS_THAN_50_M;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_RelevanceDistanceType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RelevanceTrafficDirectionType_Initialize(V2xFac_RelevanceTrafficDirectionType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_ALL_TRAFFIC_DIRECTIONS;
}

flag V2xFac_RelevanceTrafficDirectionType_IsConstraintValid(const V2xFac_RelevanceTrafficDirectionType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((*(pVal)) == v2XFAC_RELEVANCETRAFFICDIRECTION_ALL_TRAFFIC_DIRECTIONS)) || (((*(pVal)) == v2XFAC_RELEVANCETRAFFICDIRECTION_UPSTREAM_TRAFFIC)))) || (((*(pVal)) == v2XFAC_RELEVANCETRAFFICDIRECTION_DOWNSTREAM_TRAFFIC)))) || (((*(pVal)) == v2XFAC_RELEVANCETRAFFICDIRECTION_OPPOSITE_TRAFFIC)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_RELEVANCETRAFFICDIRECTIONTYPE; 

	return ret;
}

flag V2xFac_RelevanceTrafficDirectionType_Encode(const V2xFac_RelevanceTrafficDirectionType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RelevanceTrafficDirectionType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_RELEVANCETRAFFICDIRECTION_ALL_TRAFFIC_DIRECTIONS:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case v2XFAC_RELEVANCETRAFFICDIRECTION_UPSTREAM_TRAFFIC:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case v2XFAC_RELEVANCETRAFFICDIRECTION_DOWNSTREAM_TRAFFIC:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case v2XFAC_RELEVANCETRAFFICDIRECTION_OPPOSITE_TRAFFIC:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_RELEVANCETRAFFICDIRECTIONTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RelevanceTrafficDirectionType_Decode(V2xFac_RelevanceTrafficDirectionType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_RELEVANCETRAFFICDIRECTIONTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_ALL_TRAFFIC_DIRECTIONS;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_UPSTREAM_TRAFFIC;
	                break;
	            case 2: 
	                (*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_DOWNSTREAM_TRAFFIC;
	                break;
	            case 3: 
	                (*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_OPPOSITE_TRAFFIC;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_RELEVANCETRAFFICDIRECTIONTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_RELEVANCETRAFFICDIRECTION_ALL_TRAFFIC_DIRECTIONS;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_RelevanceTrafficDirectionType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_TransmissionIntervalType_Initialize(V2xFac_TransmissionIntervalType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_TransmissionIntervalType_IsConstraintValid(const V2xFac_TransmissionIntervalType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 10000UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TRANSMISSIONINTERVALTYPE; 

	return ret;
}

flag V2xFac_TransmissionIntervalType_Encode(const V2xFac_TransmissionIntervalType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TransmissionIntervalType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TransmissionIntervalType_Decode(V2xFac_TransmissionIntervalType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 10000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TRANSMISSIONINTERVALTYPE;

	return ret  && V2xFac_TransmissionIntervalType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ValidityDurationType_Initialize(V2xFac_ValidityDurationType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_ValidityDurationType_IsConstraintValid(const V2xFac_ValidityDurationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 86400UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_VALIDITYDURATIONTYPE; 

	return ret;
}

flag V2xFac_ValidityDurationType_Encode(const V2xFac_ValidityDurationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ValidityDurationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 86400);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ValidityDurationType_Decode(V2xFac_ValidityDurationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 86400);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_VALIDITYDURATIONTYPE;

	return ret  && V2xFac_ValidityDurationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_NumberOfOccupantsType_Initialize(V2xFac_NumberOfOccupantsType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_NumberOfOccupantsType_IsConstraintValid(const V2xFac_NumberOfOccupantsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 127UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_NUMBEROFOCCUPANTSTYPE; 

	return ret;
}

flag V2xFac_NumberOfOccupantsType_Encode(const V2xFac_NumberOfOccupantsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_NumberOfOccupantsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_NumberOfOccupantsType_Decode(V2xFac_NumberOfOccupantsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_NUMBEROFOCCUPANTSTYPE;

	return ret  && V2xFac_NumberOfOccupantsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SequenceNumberType_Initialize(V2xFac_SequenceNumberType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_SequenceNumberType_IsConstraintValid(const V2xFac_SequenceNumberType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_SEQUENCENUMBERTYPE; 

	return ret;
}

flag V2xFac_SequenceNumberType_Encode(const V2xFac_SequenceNumberType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SequenceNumberType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SequenceNumberType_Decode(V2xFac_SequenceNumberType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SEQUENCENUMBERTYPE;

	return ret  && V2xFac_SequenceNumberType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ActionIdType_Initialize(V2xFac_ActionIdType* pVal)
{
	(void)pVal;



	/*set originatingStationID */
	V2xFac_StationIDType_Initialize((&(pVal->originatingStationID)));
	/*set sequenceNumber */
	V2xFac_SequenceNumberType_Initialize((&(pVal->sequenceNumber)));
}

flag V2xFac_ActionIdType_IsConstraintValid(const V2xFac_ActionIdType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_StationIDType_IsConstraintValid((&(pVal->originatingStationID)), pErrCode);
    if (ret) {
        ret = V2xFac_SequenceNumberType_IsConstraintValid((&(pVal->sequenceNumber)), pErrCode);
    }

	return ret;
}

flag V2xFac_ActionIdType_Encode(const V2xFac_ActionIdType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ActionIdType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode originatingStationID */
	    ret = V2xFac_StationIDType_Encode((&(pVal->originatingStationID)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sequenceNumber */
	        ret = V2xFac_SequenceNumberType_Encode((&(pVal->sequenceNumber)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ActionIdType_Decode(V2xFac_ActionIdType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode originatingStationID */
	ret = V2xFac_StationIDType_Decode((&(pVal->originatingStationID)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sequenceNumber */
	    ret = V2xFac_SequenceNumberType_Decode((&(pVal->sequenceNumber)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_ActionIdType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ProtectedZoneRadiusType_Initialize(V2xFac_ProtectedZoneRadiusType* pVal)
{
	(void)pVal;


	(*(pVal)) = 1;
}

flag V2xFac_ProtectedZoneRadiusType_IsConstraintValid(const V2xFac_ProtectedZoneRadiusType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 255UL));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PROTECTEDZONERADIUSTYPE; 

	return ret;
}

flag V2xFac_ProtectedZoneRadiusType_Encode(const V2xFac_ProtectedZoneRadiusType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ProtectedZoneRadiusType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ProtectedZoneRadiusType_Decode(V2xFac_ProtectedZoneRadiusType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDZONERADIUSTYPE;

	return ret  && V2xFac_ProtectedZoneRadiusType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ProtectedZoneIDType_Initialize(V2xFac_ProtectedZoneIDType* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_ProtectedZoneIDType_IsConstraintValid(const V2xFac_ProtectedZoneIDType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 134217727UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PROTECTEDZONEIDTYPE; 

	return ret;
}

flag V2xFac_ProtectedZoneIDType_Encode(const V2xFac_ProtectedZoneIDType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ProtectedZoneIDType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 134217727);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ProtectedZoneIDType_Decode(V2xFac_ProtectedZoneIDType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 134217727);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDZONEIDTYPE;

	return ret  && V2xFac_ProtectedZoneIDType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ProtectedCommunicationZoneType_Initialize(V2xFac_ProtectedCommunicationZoneType* pVal)
{
	(void)pVal;



	/*set protectedZoneType */
	V2xFac_ProtectedZoneTypeType_Initialize((&(pVal->protectedZoneType)));
	/*set expiryTime */
	pVal->exist.expiryTime = 1;
	V2xFac_TimestampItsType_Initialize((&(pVal->expiryTime)));
	/*set protectedZoneLatitude */
	V2xFac_LatitudeType_Initialize((&(pVal->protectedZoneLatitude)));
	/*set protectedZoneLongitude */
	V2xFac_LongitudeType_Initialize((&(pVal->protectedZoneLongitude)));
	/*set protectedZoneRadius */
	pVal->exist.protectedZoneRadius = 1;
	V2xFac_ProtectedZoneRadiusType_Initialize((&(pVal->protectedZoneRadius)));
	/*set protectedZoneID */
	pVal->exist.protectedZoneID = 1;
	V2xFac_ProtectedZoneIDType_Initialize((&(pVal->protectedZoneID)));
}

flag V2xFac_ProtectedCommunicationZoneType_IsConstraintValid(const V2xFac_ProtectedCommunicationZoneType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ProtectedZoneTypeType_IsConstraintValid((&(pVal->protectedZoneType)), pErrCode);
    if (ret) {
        if (pVal->exist.expiryTime) {
        	ret = V2xFac_TimestampItsType_IsConstraintValid((&(pVal->expiryTime)), pErrCode);
        }
        if (ret) {
            ret = V2xFac_LatitudeType_IsConstraintValid((&(pVal->protectedZoneLatitude)), pErrCode);
            if (ret) {
                ret = V2xFac_LongitudeType_IsConstraintValid((&(pVal->protectedZoneLongitude)), pErrCode);
                if (ret) {
                    if (pVal->exist.protectedZoneRadius) {
                    	ret = V2xFac_ProtectedZoneRadiusType_IsConstraintValid((&(pVal->protectedZoneRadius)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->exist.protectedZoneID) {
                        	ret = V2xFac_ProtectedZoneIDType_IsConstraintValid((&(pVal->protectedZoneID)), pErrCode);
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_ProtectedCommunicationZoneType_Encode(const V2xFac_ProtectedCommunicationZoneType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ProtectedCommunicationZoneType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.expiryTime);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.protectedZoneRadius);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.protectedZoneID);
	            if (ret) {
	                /*Encode protectedZoneType */
	                ret = V2xFac_ProtectedZoneTypeType_Encode((&(pVal->protectedZoneType)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode expiryTime */
	                    if (pVal->exist.expiryTime) {
	                    	ret = V2xFac_TimestampItsType_Encode((&(pVal->expiryTime)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode protectedZoneLatitude */
	                        ret = V2xFac_LatitudeType_Encode((&(pVal->protectedZoneLatitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode protectedZoneLongitude */
	                            ret = V2xFac_LongitudeType_Encode((&(pVal->protectedZoneLongitude)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode protectedZoneRadius */
	                                if (pVal->exist.protectedZoneRadius) {
	                                	ret = V2xFac_ProtectedZoneRadiusType_Encode((&(pVal->protectedZoneRadius)), pBitStrm, pErrCode, FALSE);
	                                }
	                                if (ret) {
	                                    /*Encode protectedZoneID */
	                                    if (pVal->exist.protectedZoneID) {
	                                    	ret = V2xFac_ProtectedZoneIDType_Encode((&(pVal->protectedZoneID)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ProtectedCommunicationZoneType_Decode(V2xFac_ProtectedCommunicationZoneType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.expiryTime = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDCOMMUNICATIONZONETYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.protectedZoneRadius = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDCOMMUNICATIONZONETYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.protectedZoneID = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDCOMMUNICATIONZONETYPE;
	        if (ret) {
	            /*Decode protectedZoneType */
	            ret = V2xFac_ProtectedZoneTypeType_Decode((&(pVal->protectedZoneType)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode expiryTime */
	                if (pVal->exist.expiryTime) {
	                	ret = V2xFac_TimestampItsType_Decode((&(pVal->expiryTime)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode protectedZoneLatitude */
	                    ret = V2xFac_LatitudeType_Decode((&(pVal->protectedZoneLatitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode protectedZoneLongitude */
	                        ret = V2xFac_LongitudeType_Decode((&(pVal->protectedZoneLongitude)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode protectedZoneRadius */
	                            if (pVal->exist.protectedZoneRadius) {
	                            	ret = V2xFac_ProtectedZoneRadiusType_Decode((&(pVal->protectedZoneRadius)), pBitStrm, pErrCode);
	                            }
	                            if (ret) {
	                                /*Decode protectedZoneID */
	                                if (pVal->exist.protectedZoneID) {
	                                	ret = V2xFac_ProtectedZoneIDType_Decode((&(pVal->protectedZoneID)), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_ProtectedCommunicationZoneType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ProtectedCommunicationZonesRSUType_Initialize(V2xFac_ProtectedCommunicationZonesRSUType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 16) {
	    V2xFac_ProtectedCommunicationZoneType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_ProtectedCommunicationZonesRSUType_IsConstraintValid(const V2xFac_ProtectedCommunicationZonesRSUType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 16));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_PROTECTEDCOMMUNICATIONZONESRSUTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_ProtectedCommunicationZoneType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_ProtectedCommunicationZonesRSUType_Encode(const V2xFac_ProtectedCommunicationZonesRSUType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_ProtectedCommunicationZonesRSUType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_ProtectedCommunicationZoneType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ProtectedCommunicationZonesRSUType_Decode(V2xFac_ProtectedCommunicationZonesRSUType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PROTECTEDCOMMUNICATIONZONESRSUTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_ProtectedCommunicationZoneType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_ProtectedCommunicationZonesRSUType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CenDsrcTollingZoneIDType_Initialize(V2xFac_CenDsrcTollingZoneIDType* pVal)
{
	(void)pVal;


	V2xFac_ProtectedZoneIDType_Initialize(pVal);
}

flag V2xFac_CenDsrcTollingZoneIDType_IsConstraintValid(const V2xFac_CenDsrcTollingZoneIDType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ProtectedZoneIDType_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag V2xFac_CenDsrcTollingZoneIDType_Encode(const V2xFac_CenDsrcTollingZoneIDType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CenDsrcTollingZoneIDType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = V2xFac_ProtectedZoneIDType_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CenDsrcTollingZoneIDType_Decode(V2xFac_CenDsrcTollingZoneIDType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = V2xFac_ProtectedZoneIDType_Decode(pVal, pBitStrm, pErrCode);

	return ret  && V2xFac_CenDsrcTollingZoneIDType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CenDsrcTollingZoneType_Initialize(V2xFac_CenDsrcTollingZoneType* pVal)
{
	(void)pVal;



	/*set protectedZoneLatitude */
	V2xFac_LatitudeType_Initialize((&(pVal->protectedZoneLatitude)));
	/*set protectedZoneLongitude */
	V2xFac_LongitudeType_Initialize((&(pVal->protectedZoneLongitude)));
	/*set cenDsrcTollingZoneID */
	pVal->exist.cenDsrcTollingZoneID = 1;
	V2xFac_ProtectedZoneIDType_Initialize((&(pVal->cenDsrcTollingZoneID)));
}

flag V2xFac_CenDsrcTollingZoneType_IsConstraintValid(const V2xFac_CenDsrcTollingZoneType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LatitudeType_IsConstraintValid((&(pVal->protectedZoneLatitude)), pErrCode);
    if (ret) {
        ret = V2xFac_LongitudeType_IsConstraintValid((&(pVal->protectedZoneLongitude)), pErrCode);
        if (ret) {
            if (pVal->exist.cenDsrcTollingZoneID) {
            	ret = V2xFac_ProtectedZoneIDType_IsConstraintValid((&(pVal->cenDsrcTollingZoneID)), pErrCode);
            }
        }
    }

	return ret;
}

flag V2xFac_CenDsrcTollingZoneType_Encode(const V2xFac_CenDsrcTollingZoneType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CenDsrcTollingZoneType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.cenDsrcTollingZoneID);
	    if (ret) {
	        /*Encode protectedZoneLatitude */
	        ret = V2xFac_LatitudeType_Encode((&(pVal->protectedZoneLatitude)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode protectedZoneLongitude */
	            ret = V2xFac_LongitudeType_Encode((&(pVal->protectedZoneLongitude)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode cenDsrcTollingZoneID */
	                if (pVal->exist.cenDsrcTollingZoneID) {
	                	ret = V2xFac_ProtectedZoneIDType_Encode((&(pVal->cenDsrcTollingZoneID)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CenDsrcTollingZoneType_Decode(V2xFac_CenDsrcTollingZoneType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.cenDsrcTollingZoneID = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CENDSRCTOLLINGZONETYPE;
	if (ret) {
	    /*Decode protectedZoneLatitude */
	    ret = V2xFac_LatitudeType_Decode((&(pVal->protectedZoneLatitude)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode protectedZoneLongitude */
	        ret = V2xFac_LongitudeType_Decode((&(pVal->protectedZoneLongitude)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode cenDsrcTollingZoneID */
	            if (pVal->exist.cenDsrcTollingZoneID) {
	            	ret = V2xFac_ProtectedZoneIDType_Decode((&(pVal->cenDsrcTollingZoneID)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && V2xFac_CenDsrcTollingZoneType_IsConstraintValid(pVal, pErrCode);
}

