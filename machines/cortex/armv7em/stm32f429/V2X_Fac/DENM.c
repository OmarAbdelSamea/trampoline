/*
	Code automatically generated by asn1scc tool.
	Edited by Sayed Badr:
	 * 1- Commenting all decleared global variables.
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt.h"
#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "DENM.h"

void V2xFac_ImpactReductionContainerType_Initialize(V2xFac_ImpactReductionContainerType* pVal)
{
	(void)pVal;



	/*set heightLonCarrLeft */
	V2xFac_HeightLonCarrType_Initialize((&(pVal->heightLonCarrLeft)));
	/*set heightLonCarrRight */
	V2xFac_HeightLonCarrType_Initialize((&(pVal->heightLonCarrRight)));
	/*set posLonCarrLeft */
	V2xFac_PosLonCarrType_Initialize((&(pVal->posLonCarrLeft)));
	/*set posLonCarrRight */
	V2xFac_PosLonCarrType_Initialize((&(pVal->posLonCarrRight)));
	/*set positionOfPillars */
	V2xFac_PositionOfPillarsType_Initialize((&(pVal->positionOfPillars)));
	/*set posCentMass */
	V2xFac_PosCentMassType_Initialize((&(pVal->posCentMass)));
	/*set wheelBaseVehicle */
	V2xFac_WheelBaseVehicleType_Initialize((&(pVal->wheelBaseVehicle)));
	/*set turningRadius */
	V2xFac_TurningRadiusType_Initialize((&(pVal->turningRadius)));
	/*set posFrontAx */
	V2xFac_PosFrontAxType_Initialize((&(pVal->posFrontAx)));
	/*set positionOfOccupants */
	V2xFac_PositionOfOccupantsType_Initialize((&(pVal->positionOfOccupants)));
	/*set vehicleMass */
	V2xFac_VehicleMassType_Initialize((&(pVal->vehicleMass)));
	/*set requestResponseIndication */
	V2xFac_RequestResponseIndicationType_Initialize((&(pVal->requestResponseIndication)));
}

flag V2xFac_ImpactReductionContainerType_IsConstraintValid(const V2xFac_ImpactReductionContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_HeightLonCarrType_IsConstraintValid((&(pVal->heightLonCarrLeft)), pErrCode);
    if (ret) {
        ret = V2xFac_HeightLonCarrType_IsConstraintValid((&(pVal->heightLonCarrRight)), pErrCode);
        if (ret) {
            ret = V2xFac_PosLonCarrType_IsConstraintValid((&(pVal->posLonCarrLeft)), pErrCode);
            if (ret) {
                ret = V2xFac_PosLonCarrType_IsConstraintValid((&(pVal->posLonCarrRight)), pErrCode);
                if (ret) {
                    ret = V2xFac_PositionOfPillarsType_IsConstraintValid((&(pVal->positionOfPillars)), pErrCode);
                    if (ret) {
                        ret = V2xFac_PosCentMassType_IsConstraintValid((&(pVal->posCentMass)), pErrCode);
                        if (ret) {
                            ret = V2xFac_WheelBaseVehicleType_IsConstraintValid((&(pVal->wheelBaseVehicle)), pErrCode);
                            if (ret) {
                                ret = V2xFac_TurningRadiusType_IsConstraintValid((&(pVal->turningRadius)), pErrCode);
                                if (ret) {
                                    ret = V2xFac_PosFrontAxType_IsConstraintValid((&(pVal->posFrontAx)), pErrCode);
                                    if (ret) {
                                        ret = V2xFac_PositionOfOccupantsType_IsConstraintValid((&(pVal->positionOfOccupants)), pErrCode);
                                        if (ret) {
                                            ret = V2xFac_VehicleMassType_IsConstraintValid((&(pVal->vehicleMass)), pErrCode);
                                            if (ret) {
                                                ret = V2xFac_RequestResponseIndicationType_IsConstraintValid((&(pVal->requestResponseIndication)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_ImpactReductionContainerType_Encode(const V2xFac_ImpactReductionContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ImpactReductionContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heightLonCarrLeft */
	    ret = V2xFac_HeightLonCarrType_Encode((&(pVal->heightLonCarrLeft)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heightLonCarrRight */
	        ret = V2xFac_HeightLonCarrType_Encode((&(pVal->heightLonCarrRight)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode posLonCarrLeft */
	            ret = V2xFac_PosLonCarrType_Encode((&(pVal->posLonCarrLeft)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode posLonCarrRight */
	                ret = V2xFac_PosLonCarrType_Encode((&(pVal->posLonCarrRight)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode positionOfPillars */
	                    ret = V2xFac_PositionOfPillarsType_Encode((&(pVal->positionOfPillars)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode posCentMass */
	                        ret = V2xFac_PosCentMassType_Encode((&(pVal->posCentMass)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode wheelBaseVehicle */
	                            ret = V2xFac_WheelBaseVehicleType_Encode((&(pVal->wheelBaseVehicle)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode turningRadius */
	                                ret = V2xFac_TurningRadiusType_Encode((&(pVal->turningRadius)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode posFrontAx */
	                                    ret = V2xFac_PosFrontAxType_Encode((&(pVal->posFrontAx)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode positionOfOccupants */
	                                        ret = V2xFac_PositionOfOccupantsType_Encode((&(pVal->positionOfOccupants)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode vehicleMass */
	                                            ret = V2xFac_VehicleMassType_Encode((&(pVal->vehicleMass)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode requestResponseIndication */
	                                                ret = V2xFac_RequestResponseIndicationType_Encode((&(pVal->requestResponseIndication)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ImpactReductionContainerType_Decode(V2xFac_ImpactReductionContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode heightLonCarrLeft */
	ret = V2xFac_HeightLonCarrType_Decode((&(pVal->heightLonCarrLeft)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heightLonCarrRight */
	    ret = V2xFac_HeightLonCarrType_Decode((&(pVal->heightLonCarrRight)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode posLonCarrLeft */
	        ret = V2xFac_PosLonCarrType_Decode((&(pVal->posLonCarrLeft)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode posLonCarrRight */
	            ret = V2xFac_PosLonCarrType_Decode((&(pVal->posLonCarrRight)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode positionOfPillars */
	                ret = V2xFac_PositionOfPillarsType_Decode((&(pVal->positionOfPillars)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode posCentMass */
	                    ret = V2xFac_PosCentMassType_Decode((&(pVal->posCentMass)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode wheelBaseVehicle */
	                        ret = V2xFac_WheelBaseVehicleType_Decode((&(pVal->wheelBaseVehicle)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode turningRadius */
	                            ret = V2xFac_TurningRadiusType_Decode((&(pVal->turningRadius)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode posFrontAx */
	                                ret = V2xFac_PosFrontAxType_Decode((&(pVal->posFrontAx)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode positionOfOccupants */
	                                    ret = V2xFac_PositionOfOccupantsType_Decode((&(pVal->positionOfOccupants)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode vehicleMass */
	                                        ret = V2xFac_VehicleMassType_Decode((&(pVal->vehicleMass)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode requestResponseIndication */
	                                            ret = V2xFac_RequestResponseIndicationType_Decode((&(pVal->requestResponseIndication)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_ImpactReductionContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_SituationContainerType_Initialize(V2xFac_SituationContainerType* pVal)
{
	(void)pVal;



	/*set informationQuality */
	V2xFac_InformationQualityType_Initialize((&(pVal->informationQuality)));
	/*set eventType */
	V2xFac_CauseCodeType_Initialize((&(pVal->eventType)));
	/*set linkedCause */
	pVal->exist.linkedCause = 1;
	V2xFac_CauseCodeType_Initialize((&(pVal->linkedCause)));
	/*set eventHistory */
	pVal->exist.eventHistory = 1;
	V2xFac_EventHistoryType_Initialize((&(pVal->eventHistory)));
}

flag V2xFac_SituationContainerType_IsConstraintValid(const V2xFac_SituationContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_InformationQualityType_IsConstraintValid((&(pVal->informationQuality)), pErrCode);
    if (ret) {
        ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->eventType)), pErrCode);
        if (ret) {
            if (pVal->exist.linkedCause) {
            	ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->linkedCause)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.eventHistory) {
                	ret = V2xFac_EventHistoryType_IsConstraintValid((&(pVal->eventHistory)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag V2xFac_SituationContainerType_Encode(const V2xFac_SituationContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SituationContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.linkedCause);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.eventHistory);
	        if (ret) {
	            /*Encode informationQuality */
	            ret = V2xFac_InformationQualityType_Encode((&(pVal->informationQuality)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode eventType */
	                ret = V2xFac_CauseCodeType_Encode((&(pVal->eventType)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode linkedCause */
	                    if (pVal->exist.linkedCause) {
	                    	ret = V2xFac_CauseCodeType_Encode((&(pVal->linkedCause)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode eventHistory */
	                        if (pVal->exist.eventHistory) {
	                        	ret = V2xFac_EventHistoryType_Encode((&(pVal->eventHistory)), pBitStrm, pErrCode, FALSE);
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SituationContainerType_Decode(V2xFac_SituationContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.linkedCause = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SITUATIONCONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.eventHistory = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SITUATIONCONTAINERTYPE;
	    if (ret) {
	        /*Decode informationQuality */
	        ret = V2xFac_InformationQualityType_Decode((&(pVal->informationQuality)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode eventType */
	            ret = V2xFac_CauseCodeType_Decode((&(pVal->eventType)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode linkedCause */
	                if (pVal->exist.linkedCause) {
	                	ret = V2xFac_CauseCodeType_Decode((&(pVal->linkedCause)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode eventHistory */
	                    if (pVal->exist.eventHistory) {
	                    	ret = V2xFac_EventHistoryType_Decode((&(pVal->eventHistory)), pBitStrm, pErrCode);
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_SituationContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_LocationContainerType_Initialize(V2xFac_LocationContainerType* pVal)
{
	(void)pVal;



	/*set eventSpeed */
	pVal->exist.eventSpeed = 1;
	V2xFac_SpeedType_Initialize((&(pVal->eventSpeed)));
	/*set eventPositionHeading */
	pVal->exist.eventPositionHeading = 1;
	V2xFac_HeadingType_Initialize((&(pVal->eventPositionHeading)));
	/*set traces */
	V2xFac_TracesType_Initialize((&(pVal->traces)));
	/*set roadType */
	pVal->exist.roadType = 1;
	V2xFac_RoadTypeType_Initialize((&(pVal->roadType)));
}

flag V2xFac_LocationContainerType_IsConstraintValid(const V2xFac_LocationContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.eventSpeed) {
    	ret = V2xFac_SpeedType_IsConstraintValid((&(pVal->eventSpeed)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.eventPositionHeading) {
        	ret = V2xFac_HeadingType_IsConstraintValid((&(pVal->eventPositionHeading)), pErrCode);
        }
        if (ret) {
            ret = V2xFac_TracesType_IsConstraintValid((&(pVal->traces)), pErrCode);
            if (ret) {
                if (pVal->exist.roadType) {
                	ret = V2xFac_RoadTypeType_IsConstraintValid((&(pVal->roadType)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag V2xFac_LocationContainerType_Encode(const V2xFac_LocationContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LocationContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.eventSpeed);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.eventPositionHeading);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.roadType);
	            if (ret) {
	                /*Encode eventSpeed */
	                if (pVal->exist.eventSpeed) {
	                	ret = V2xFac_SpeedType_Encode((&(pVal->eventSpeed)), pBitStrm, pErrCode, FALSE);
	                }
	                if (ret) {
	                    /*Encode eventPositionHeading */
	                    if (pVal->exist.eventPositionHeading) {
	                    	ret = V2xFac_HeadingType_Encode((&(pVal->eventPositionHeading)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode traces */
	                        ret = V2xFac_TracesType_Encode((&(pVal->traces)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode roadType */
	                            if (pVal->exist.roadType) {
	                            	ret = V2xFac_RoadTypeType_Encode((&(pVal->roadType)), pBitStrm, pErrCode, FALSE);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LocationContainerType_Decode(V2xFac_LocationContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.eventSpeed = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LOCATIONCONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.eventPositionHeading = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LOCATIONCONTAINERTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.roadType = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LOCATIONCONTAINERTYPE;
	        if (ret) {
	            /*Decode eventSpeed */
	            if (pVal->exist.eventSpeed) {
	            	ret = V2xFac_SpeedType_Decode((&(pVal->eventSpeed)), pBitStrm, pErrCode);
	            }
	            if (ret) {
	                /*Decode eventPositionHeading */
	                if (pVal->exist.eventPositionHeading) {
	                	ret = V2xFac_HeadingType_Decode((&(pVal->eventPositionHeading)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode traces */
	                    ret = V2xFac_TracesType_Decode((&(pVal->traces)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode roadType */
	                        if (pVal->exist.roadType) {
	                        	ret = V2xFac_RoadTypeType_Decode((&(pVal->roadType)), pBitStrm, pErrCode);
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_LocationContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_StationaryVehicleContainerType_Initialize(V2xFac_StationaryVehicleContainerType* pVal)
{
	(void)pVal;



	/*set stationarySince */
	pVal->exist.stationarySince = 1;
	V2xFac_StationarySinceType_Initialize((&(pVal->stationarySince)));
	/*set stationaryCause */
	pVal->exist.stationaryCause = 1;
	V2xFac_CauseCodeType_Initialize((&(pVal->stationaryCause)));
	/*set carryingDangerousGoods */
	pVal->exist.carryingDangerousGoods = 1;
	V2xFac_DangerousGoodsExtendedType_Initialize((&(pVal->carryingDangerousGoods)));
	/*set numberOfOccupants */
	pVal->exist.numberOfOccupants = 1;
	V2xFac_NumberOfOccupantsType_Initialize((&(pVal->numberOfOccupants)));
	/*set vehicleIdentification */
	pVal->exist.vehicleIdentification = 1;
	V2xFac_VehicleIdentificationType_Initialize((&(pVal->vehicleIdentification)));
	/*set energyStorageType */
	pVal->exist.energyStorageType = 1;
	V2xFac_EnergyStorageTypeType_Initialize((&(pVal->energyStorageType)));
}

flag V2xFac_StationaryVehicleContainerType_IsConstraintValid(const V2xFac_StationaryVehicleContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.stationarySince) {
    	ret = V2xFac_StationarySinceType_IsConstraintValid((&(pVal->stationarySince)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.stationaryCause) {
        	ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->stationaryCause)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.carryingDangerousGoods) {
            	ret = V2xFac_DangerousGoodsExtendedType_IsConstraintValid((&(pVal->carryingDangerousGoods)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.numberOfOccupants) {
                	ret = V2xFac_NumberOfOccupantsType_IsConstraintValid((&(pVal->numberOfOccupants)), pErrCode);
                }
                if (ret) {
                    if (pVal->exist.vehicleIdentification) {
                    	ret = V2xFac_VehicleIdentificationType_IsConstraintValid((&(pVal->vehicleIdentification)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->exist.energyStorageType) {
                        	ret = V2xFac_EnergyStorageTypeType_IsConstraintValid((&(pVal->energyStorageType)), pErrCode);
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_StationaryVehicleContainerType_Encode(const V2xFac_StationaryVehicleContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_StationaryVehicleContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.stationarySince);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.stationaryCause);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.carryingDangerousGoods);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.numberOfOccupants);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.vehicleIdentification);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.energyStorageType);
	                        if (ret) {
	                            /*Encode stationarySince */
	                            if (pVal->exist.stationarySince) {
	                            	ret = V2xFac_StationarySinceType_Encode((&(pVal->stationarySince)), pBitStrm, pErrCode, FALSE);
	                            }
	                            if (ret) {
	                                /*Encode stationaryCause */
	                                if (pVal->exist.stationaryCause) {
	                                	ret = V2xFac_CauseCodeType_Encode((&(pVal->stationaryCause)), pBitStrm, pErrCode, FALSE);
	                                }
	                                if (ret) {
	                                    /*Encode carryingDangerousGoods */
	                                    if (pVal->exist.carryingDangerousGoods) {
	                                    	ret = V2xFac_DangerousGoodsExtendedType_Encode((&(pVal->carryingDangerousGoods)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode numberOfOccupants */
	                                        if (pVal->exist.numberOfOccupants) {
	                                        	ret = V2xFac_NumberOfOccupantsType_Encode((&(pVal->numberOfOccupants)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                        if (ret) {
	                                            /*Encode vehicleIdentification */
	                                            if (pVal->exist.vehicleIdentification) {
	                                            	ret = V2xFac_VehicleIdentificationType_Encode((&(pVal->vehicleIdentification)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode energyStorageType */
	                                                if (pVal->exist.energyStorageType) {
	                                                	ret = V2xFac_EnergyStorageTypeType_Encode((&(pVal->energyStorageType)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_StationaryVehicleContainerType_Decode(V2xFac_StationaryVehicleContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.stationarySince = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.stationaryCause = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.carryingDangerousGoods = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.numberOfOccupants = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.vehicleIdentification = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.energyStorageType = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_STATIONARYVEHICLECONTAINERTYPE;
	                    if (ret) {
	                        /*Decode stationarySince */
	                        if (pVal->exist.stationarySince) {
	                        	ret = V2xFac_StationarySinceType_Decode((&(pVal->stationarySince)), pBitStrm, pErrCode);
	                        }
	                        if (ret) {
	                            /*Decode stationaryCause */
	                            if (pVal->exist.stationaryCause) {
	                            	ret = V2xFac_CauseCodeType_Decode((&(pVal->stationaryCause)), pBitStrm, pErrCode);
	                            }
	                            if (ret) {
	                                /*Decode carryingDangerousGoods */
	                                if (pVal->exist.carryingDangerousGoods) {
	                                	ret = V2xFac_DangerousGoodsExtendedType_Decode((&(pVal->carryingDangerousGoods)), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode numberOfOccupants */
	                                    if (pVal->exist.numberOfOccupants) {
	                                    	ret = V2xFac_NumberOfOccupantsType_Decode((&(pVal->numberOfOccupants)), pBitStrm, pErrCode);
	                                    }
	                                    if (ret) {
	                                        /*Decode vehicleIdentification */
	                                        if (pVal->exist.vehicleIdentification) {
	                                        	ret = V2xFac_VehicleIdentificationType_Decode((&(pVal->vehicleIdentification)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode energyStorageType */
	                                            if (pVal->exist.energyStorageType) {
	                                            	ret = V2xFac_EnergyStorageTypeType_Decode((&(pVal->energyStorageType)), pBitStrm, pErrCode);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_StationaryVehicleContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_ReferenceDenmsType_Initialize(V2xFac_ReferenceDenmsType* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 8) {
	    V2xFac_ActionIdType_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag V2xFac_ReferenceDenmsType_IsConstraintValid(const V2xFac_ReferenceDenmsType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 8));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_REFERENCEDENMSTYPE; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = V2xFac_ActionIdType_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_ReferenceDenmsType_Encode(const V2xFac_ReferenceDenmsType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? V2xFac_ReferenceDenmsType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 8);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = V2xFac_ActionIdType_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ReferenceDenmsType_Decode(V2xFac_ReferenceDenmsType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 8);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_REFERENCEDENMSTYPE;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = V2xFac_ActionIdType_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_ReferenceDenmsType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RoadWorksContainerExtendedType_Initialize(V2xFac_RoadWorksContainerExtendedType* pVal)
{
	(void)pVal;



	/*set lightBarSirenInUse */
	pVal->exist.lightBarSirenInUse = 1;
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
	/*set closedLanes */
	pVal->exist.closedLanes = 1;
	V2xFac_ClosedLanesType_Initialize((&(pVal->closedLanes)));
	/*set restriction */
	pVal->exist.restriction = 1;
	V2xFac_RestrictedTypesType_Initialize((&(pVal->restriction)));
	/*set speedLimit */
	pVal->exist.speedLimit = 1;
	V2xFac_SpeedLimitType_Initialize((&(pVal->speedLimit)));
	/*set incidentIndication */
	pVal->exist.incidentIndication = 1;
	V2xFac_CauseCodeType_Initialize((&(pVal->incidentIndication)));
	/*set recommendedPath */
	pVal->exist.recommendedPath = 1;
	V2xFac_ItineraryPathType_Initialize((&(pVal->recommendedPath)));
	/*set startingPointSpeedLimit */
	pVal->exist.startingPointSpeedLimit = 1;
	V2xFac_DeltaReferencePositionType_Initialize((&(pVal->startingPointSpeedLimit)));
	/*set trafficFlowRule */
	pVal->exist.trafficFlowRule = 1;
	V2xFac_TrafficRuleType_Initialize((&(pVal->trafficFlowRule)));
	/*set referenceDenms */
	pVal->exist.referenceDenms = 1;
	V2xFac_ReferenceDenmsType_Initialize((&(pVal->referenceDenms)));
}

flag V2xFac_RoadWorksContainerExtendedType_IsConstraintValid(const V2xFac_RoadWorksContainerExtendedType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.lightBarSirenInUse) {
    	ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.closedLanes) {
        	ret = V2xFac_ClosedLanesType_IsConstraintValid((&(pVal->closedLanes)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.restriction) {
            	ret = V2xFac_RestrictedTypesType_IsConstraintValid((&(pVal->restriction)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.speedLimit) {
                	ret = V2xFac_SpeedLimitType_IsConstraintValid((&(pVal->speedLimit)), pErrCode);
                }
                if (ret) {
                    if (pVal->exist.incidentIndication) {
                    	ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->incidentIndication)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->exist.recommendedPath) {
                        	ret = V2xFac_ItineraryPathType_IsConstraintValid((&(pVal->recommendedPath)), pErrCode);
                        }
                        if (ret) {
                            if (pVal->exist.startingPointSpeedLimit) {
                            	ret = V2xFac_DeltaReferencePositionType_IsConstraintValid((&(pVal->startingPointSpeedLimit)), pErrCode);
                            }
                            if (ret) {
                                if (pVal->exist.trafficFlowRule) {
                                	ret = V2xFac_TrafficRuleType_IsConstraintValid((&(pVal->trafficFlowRule)), pErrCode);
                                }
                                if (ret) {
                                    if (pVal->exist.referenceDenms) {
                                    	ret = V2xFac_ReferenceDenmsType_IsConstraintValid((&(pVal->referenceDenms)), pErrCode);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_RoadWorksContainerExtendedType_Encode(const V2xFac_RoadWorksContainerExtendedType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RoadWorksContainerExtendedType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.lightBarSirenInUse);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.closedLanes);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.restriction);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.speedLimit);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.incidentIndication);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.recommendedPath);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.startingPointSpeedLimit);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.trafficFlowRule);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.referenceDenms);
	                                    if (ret) {
	                                        /*Encode lightBarSirenInUse */
	                                        if (pVal->exist.lightBarSirenInUse) {
	                                        	ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                        if (ret) {
	                                            /*Encode closedLanes */
	                                            if (pVal->exist.closedLanes) {
	                                            	ret = V2xFac_ClosedLanesType_Encode((&(pVal->closedLanes)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode restriction */
	                                                if (pVal->exist.restriction) {
	                                                	ret = V2xFac_RestrictedTypesType_Encode((&(pVal->restriction)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                                if (ret) {
	                                                    /*Encode speedLimit */
	                                                    if (pVal->exist.speedLimit) {
	                                                    	ret = V2xFac_SpeedLimitType_Encode((&(pVal->speedLimit)), pBitStrm, pErrCode, FALSE);
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode incidentIndication */
	                                                        if (pVal->exist.incidentIndication) {
	                                                        	ret = V2xFac_CauseCodeType_Encode((&(pVal->incidentIndication)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode recommendedPath */
	                                                            if (pVal->exist.recommendedPath) {
	                                                            	ret = V2xFac_ItineraryPathType_Encode((&(pVal->recommendedPath)), pBitStrm, pErrCode, FALSE);
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode startingPointSpeedLimit */
	                                                                if (pVal->exist.startingPointSpeedLimit) {
	                                                                	ret = V2xFac_DeltaReferencePositionType_Encode((&(pVal->startingPointSpeedLimit)), pBitStrm, pErrCode, FALSE);
	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode trafficFlowRule */
	                                                                    if (pVal->exist.trafficFlowRule) {
	                                                                    	ret = V2xFac_TrafficRuleType_Encode((&(pVal->trafficFlowRule)), pBitStrm, pErrCode, FALSE);
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode referenceDenms */
	                                                                        if (pVal->exist.referenceDenms) {
	                                                                        	ret = V2xFac_ReferenceDenmsType_Encode((&(pVal->referenceDenms)), pBitStrm, pErrCode, FALSE);
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RoadWorksContainerExtendedType_Decode(V2xFac_RoadWorksContainerExtendedType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.lightBarSirenInUse = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.closedLanes = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.restriction = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.speedLimit = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.incidentIndication = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.recommendedPath = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.startingPointSpeedLimit = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.trafficFlowRule = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.referenceDenms = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINEREXTENDEDTYPE;
	                                if (ret) {
	                                    /*Decode lightBarSirenInUse */
	                                    if (pVal->exist.lightBarSirenInUse) {
	                                    	ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);
	                                    }
	                                    if (ret) {
	                                        /*Decode closedLanes */
	                                        if (pVal->exist.closedLanes) {
	                                        	ret = V2xFac_ClosedLanesType_Decode((&(pVal->closedLanes)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode restriction */
	                                            if (pVal->exist.restriction) {
	                                            	ret = V2xFac_RestrictedTypesType_Decode((&(pVal->restriction)), pBitStrm, pErrCode);
	                                            }
	                                            if (ret) {
	                                                /*Decode speedLimit */
	                                                if (pVal->exist.speedLimit) {
	                                                	ret = V2xFac_SpeedLimitType_Decode((&(pVal->speedLimit)), pBitStrm, pErrCode);
	                                                }
	                                                if (ret) {
	                                                    /*Decode incidentIndication */
	                                                    if (pVal->exist.incidentIndication) {
	                                                    	ret = V2xFac_CauseCodeType_Decode((&(pVal->incidentIndication)), pBitStrm, pErrCode);
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode recommendedPath */
	                                                        if (pVal->exist.recommendedPath) {
	                                                        	ret = V2xFac_ItineraryPathType_Decode((&(pVal->recommendedPath)), pBitStrm, pErrCode);
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode startingPointSpeedLimit */
	                                                            if (pVal->exist.startingPointSpeedLimit) {
	                                                            	ret = V2xFac_DeltaReferencePositionType_Decode((&(pVal->startingPointSpeedLimit)), pBitStrm, pErrCode);
	                                                            }
	                                                            if (ret) {
	                                                                /*Decode trafficFlowRule */
	                                                                if (pVal->exist.trafficFlowRule) {
	                                                                	ret = V2xFac_TrafficRuleType_Decode((&(pVal->trafficFlowRule)), pBitStrm, pErrCode);
	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode referenceDenms */
	                                                                    if (pVal->exist.referenceDenms) {
	                                                                    	ret = V2xFac_ReferenceDenmsType_Decode((&(pVal->referenceDenms)), pBitStrm, pErrCode);
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_RoadWorksContainerExtendedType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_AlacarteContainerType_Initialize(V2xFac_AlacarteContainerType* pVal)
{
	(void)pVal;



	/*set lanePosition */
	pVal->exist.lanePosition = 1;
	V2xFac_LanePositionType_Initialize((&(pVal->lanePosition)));
	/*set impactReduction */
	pVal->exist.impactReduction = 1;
	V2xFac_ImpactReductionContainerType_Initialize((&(pVal->impactReduction)));
	/*set externalTemperature */
	pVal->exist.externalTemperature = 1;
	V2xFac_TemperatureType_Initialize((&(pVal->externalTemperature)));
	/*set roadWorks */
	pVal->exist.roadWorks = 1;
	V2xFac_RoadWorksContainerExtendedType_Initialize((&(pVal->roadWorks)));
	/*set positioningSolution */
	pVal->exist.positioningSolution = 1;
	V2xFac_PositioningSolutionTypeType_Initialize((&(pVal->positioningSolution)));
	/*set stationaryVehicle */
	pVal->exist.stationaryVehicle = 1;
	V2xFac_StationaryVehicleContainerType_Initialize((&(pVal->stationaryVehicle)));
}

flag V2xFac_AlacarteContainerType_IsConstraintValid(const V2xFac_AlacarteContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.lanePosition) {
    	ret = V2xFac_LanePositionType_IsConstraintValid((&(pVal->lanePosition)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.impactReduction) {
        	ret = V2xFac_ImpactReductionContainerType_IsConstraintValid((&(pVal->impactReduction)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.externalTemperature) {
            	ret = V2xFac_TemperatureType_IsConstraintValid((&(pVal->externalTemperature)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.roadWorks) {
                	ret = V2xFac_RoadWorksContainerExtendedType_IsConstraintValid((&(pVal->roadWorks)), pErrCode);
                }
                if (ret) {
                    if (pVal->exist.positioningSolution) {
                    	ret = V2xFac_PositioningSolutionTypeType_IsConstraintValid((&(pVal->positioningSolution)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->exist.stationaryVehicle) {
                        	ret = V2xFac_StationaryVehicleContainerType_IsConstraintValid((&(pVal->stationaryVehicle)), pErrCode);
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_AlacarteContainerType_Encode(const V2xFac_AlacarteContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_AlacarteContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.lanePosition);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.impactReduction);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.externalTemperature);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.roadWorks);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.positioningSolution);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.stationaryVehicle);
	                        if (ret) {
	                            /*Encode lanePosition */
	                            if (pVal->exist.lanePosition) {
	                            	ret = V2xFac_LanePositionType_Encode((&(pVal->lanePosition)), pBitStrm, pErrCode, FALSE);
	                            }
	                            if (ret) {
	                                /*Encode impactReduction */
	                                if (pVal->exist.impactReduction) {
	                                	ret = V2xFac_ImpactReductionContainerType_Encode((&(pVal->impactReduction)), pBitStrm, pErrCode, FALSE);
	                                }
	                                if (ret) {
	                                    /*Encode externalTemperature */
	                                    if (pVal->exist.externalTemperature) {
	                                    	ret = V2xFac_TemperatureType_Encode((&(pVal->externalTemperature)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode roadWorks */
	                                        if (pVal->exist.roadWorks) {
	                                        	ret = V2xFac_RoadWorksContainerExtendedType_Encode((&(pVal->roadWorks)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                        if (ret) {
	                                            /*Encode positioningSolution */
	                                            if (pVal->exist.positioningSolution) {
	                                            	ret = V2xFac_PositioningSolutionTypeType_Encode((&(pVal->positioningSolution)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode stationaryVehicle */
	                                                if (pVal->exist.stationaryVehicle) {
	                                                	ret = V2xFac_StationaryVehicleContainerType_Encode((&(pVal->stationaryVehicle)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_AlacarteContainerType_Decode(V2xFac_AlacarteContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.lanePosition = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.impactReduction = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.externalTemperature = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.roadWorks = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.positioningSolution = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.stationaryVehicle = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ALACARTECONTAINERTYPE;
	                    if (ret) {
	                        /*Decode lanePosition */
	                        if (pVal->exist.lanePosition) {
	                        	ret = V2xFac_LanePositionType_Decode((&(pVal->lanePosition)), pBitStrm, pErrCode);
	                        }
	                        if (ret) {
	                            /*Decode impactReduction */
	                            if (pVal->exist.impactReduction) {
	                            	ret = V2xFac_ImpactReductionContainerType_Decode((&(pVal->impactReduction)), pBitStrm, pErrCode);
	                            }
	                            if (ret) {
	                                /*Decode externalTemperature */
	                                if (pVal->exist.externalTemperature) {
	                                	ret = V2xFac_TemperatureType_Decode((&(pVal->externalTemperature)), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode roadWorks */
	                                    if (pVal->exist.roadWorks) {
	                                    	ret = V2xFac_RoadWorksContainerExtendedType_Decode((&(pVal->roadWorks)), pBitStrm, pErrCode);
	                                    }
	                                    if (ret) {
	                                        /*Decode positioningSolution */
	                                        if (pVal->exist.positioningSolution) {
	                                        	ret = V2xFac_PositioningSolutionTypeType_Decode((&(pVal->positioningSolution)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode stationaryVehicle */
	                                            if (pVal->exist.stationaryVehicle) {
	                                            	ret = V2xFac_StationaryVehicleContainerType_Decode((&(pVal->stationaryVehicle)), pBitStrm, pErrCode);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_AlacarteContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_TerminationType_Initialize(V2xFac_TerminationType* pVal)
{
	(void)pVal;


	(*(pVal)) = v2XFAC_TERMINATION_TYPE_IS_CANCELLATION;
}

flag V2xFac_TerminationType_IsConstraintValid(const V2xFac_TerminationType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == v2XFAC_TERMINATION_TYPE_IS_CANCELLATION)) || (((*(pVal)) == v2XFAC_TERMINATION_TYPE_IS_NEGATION)));
    *pErrCode = ret ? 0 :  ERR_V2XFAC_TERMINATIONTYPE; 

	return ret;
}

flag V2xFac_TerminationType_Encode(const V2xFac_TerminationType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_TerminationType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case v2XFAC_TERMINATION_TYPE_IS_CANCELLATION:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case v2XFAC_TERMINATION_TYPE_IS_NEGATION:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_V2XFAC_TERMINATIONTYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_TerminationType_Decode(V2xFac_TerminationType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_TERMINATIONTYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = v2XFAC_TERMINATION_TYPE_IS_CANCELLATION;
	                break;
	            case 1: 
	                (*(pVal)) = v2XFAC_TERMINATION_TYPE_IS_NEGATION;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_V2XFAC_TERMINATIONTYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = v2XFAC_TERMINATION_TYPE_IS_CANCELLATION;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && V2xFac_TerminationType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_ManagementContainerType_Initialize(V2xFac_ManagementContainerType* pVal)
{
	(void)pVal;



	/*set actionID */
	V2xFac_ActionIdType_Initialize((&(pVal->actionID)));
	/*set detectionTime */
	V2xFac_TimestampItsType_Initialize((&(pVal->detectionTime)));
	/*set referenceTime */
	V2xFac_TimestampItsType_Initialize((&(pVal->referenceTime)));
	/*set termination */
	pVal->exist.termination = 1;
	V2xFac_TerminationType_Initialize((&(pVal->termination)));
	/*set eventPosition */
	V2xFac_ReferencePositionType_Initialize((&(pVal->eventPosition)));
	/*set relevanceDistance */
	pVal->exist.relevanceDistance = 1;
	V2xFac_RelevanceDistanceType_Initialize((&(pVal->relevanceDistance)));
	/*set relevanceTrafficDirection */
	pVal->exist.relevanceTrafficDirection = 1;
	V2xFac_RelevanceTrafficDirectionType_Initialize((&(pVal->relevanceTrafficDirection)));
	/*set validityDuration */
	pVal->exist.validityDuration = 1;
	pVal->validityDuration = 600;
	/*set transmissionInterval */
	pVal->exist.transmissionInterval = 1;
	V2xFac_TransmissionIntervalType_Initialize((&(pVal->transmissionInterval)));
	/*set stationType */
	V2xFac_StationTypeType_Initialize((&(pVal->stationType)));
}

flag V2xFac_ManagementContainerType_IsConstraintValid(const V2xFac_ManagementContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ActionIdType_IsConstraintValid((&(pVal->actionID)), pErrCode);
    if (ret) {
        ret = V2xFac_TimestampItsType_IsConstraintValid((&(pVal->detectionTime)), pErrCode);
        if (ret) {
            ret = V2xFac_TimestampItsType_IsConstraintValid((&(pVal->referenceTime)), pErrCode);
            if (ret) {
                if (pVal->exist.termination) {
                	ret = V2xFac_TerminationType_IsConstraintValid((&(pVal->termination)), pErrCode);
                }
                if (ret) {
                    ret = V2xFac_ReferencePositionType_IsConstraintValid((&(pVal->eventPosition)), pErrCode);
                    if (ret) {
                        if (pVal->exist.relevanceDistance) {
                        	ret = V2xFac_RelevanceDistanceType_IsConstraintValid((&(pVal->relevanceDistance)), pErrCode);
                        }
                        if (ret) {
                            if (pVal->exist.relevanceTrafficDirection) {
                            	ret = V2xFac_RelevanceTrafficDirectionType_IsConstraintValid((&(pVal->relevanceTrafficDirection)), pErrCode);
                            }
                            if (ret) {
                                if (pVal->exist.validityDuration) {
                                	ret = V2xFac_ValidityDurationType_IsConstraintValid((&(pVal->validityDuration)), pErrCode);
                                }
                                if (ret) {
                                    if (pVal->exist.transmissionInterval) {
                                    	ret = V2xFac_TransmissionIntervalType_IsConstraintValid((&(pVal->transmissionInterval)), pErrCode);
                                    }
                                    if (ret) {
                                        ret = V2xFac_StationTypeType_IsConstraintValid((&(pVal->stationType)), pErrCode);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_ManagementContainerType_Encode(const V2xFac_ManagementContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_ManagementContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.termination);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.relevanceDistance);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.relevanceTrafficDirection);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.validityDuration);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.transmissionInterval);
	                    if (ret) {
	                        /*Encode actionID */
	                        ret = V2xFac_ActionIdType_Encode((&(pVal->actionID)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode detectionTime */
	                            ret = V2xFac_TimestampItsType_Encode((&(pVal->detectionTime)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode referenceTime */
	                                ret = V2xFac_TimestampItsType_Encode((&(pVal->referenceTime)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode termination */
	                                    if (pVal->exist.termination) {
	                                    	ret = V2xFac_TerminationType_Encode((&(pVal->termination)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode eventPosition */
	                                        ret = V2xFac_ReferencePositionType_Encode((&(pVal->eventPosition)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode relevanceDistance */
	                                            if (pVal->exist.relevanceDistance) {
	                                            	ret = V2xFac_RelevanceDistanceType_Encode((&(pVal->relevanceDistance)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode relevanceTrafficDirection */
	                                                if (pVal->exist.relevanceTrafficDirection) {
	                                                	ret = V2xFac_RelevanceTrafficDirectionType_Encode((&(pVal->relevanceTrafficDirection)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                                if (ret) {
	                                                    /*Encode validityDuration */
	                                                    if (pVal->exist.validityDuration) {
	                                                    	ret = V2xFac_ValidityDurationType_Encode((&(pVal->validityDuration)), pBitStrm, pErrCode, FALSE);
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode transmissionInterval */
	                                                        if (pVal->exist.transmissionInterval) {
	                                                        	ret = V2xFac_TransmissionIntervalType_Encode((&(pVal->transmissionInterval)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode stationType */
	                                                            ret = V2xFac_StationTypeType_Encode((&(pVal->stationType)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_ManagementContainerType_Decode(V2xFac_ManagementContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.termination = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_MANAGEMENTCONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.relevanceDistance = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_MANAGEMENTCONTAINERTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.relevanceTrafficDirection = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_MANAGEMENTCONTAINERTYPE;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.validityDuration = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_MANAGEMENTCONTAINERTYPE;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.transmissionInterval = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_MANAGEMENTCONTAINERTYPE;
	                if (ret) {
	                    /*Decode actionID */
	                    ret = V2xFac_ActionIdType_Decode((&(pVal->actionID)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode detectionTime */
	                        ret = V2xFac_TimestampItsType_Decode((&(pVal->detectionTime)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode referenceTime */
	                            ret = V2xFac_TimestampItsType_Decode((&(pVal->referenceTime)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode termination */
	                                if (pVal->exist.termination) {
	                                	ret = V2xFac_TerminationType_Decode((&(pVal->termination)), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode eventPosition */
	                                    ret = V2xFac_ReferencePositionType_Decode((&(pVal->eventPosition)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode relevanceDistance */
	                                        if (pVal->exist.relevanceDistance) {
	                                        	ret = V2xFac_RelevanceDistanceType_Decode((&(pVal->relevanceDistance)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode relevanceTrafficDirection */
	                                            if (pVal->exist.relevanceTrafficDirection) {
	                                            	ret = V2xFac_RelevanceTrafficDirectionType_Decode((&(pVal->relevanceTrafficDirection)), pBitStrm, pErrCode);
	                                            }
	                                            if (ret) {
	                                                /*Decode validityDuration */
	                                                if (pVal->exist.validityDuration) {
	                                                	ret = V2xFac_ValidityDurationType_Decode((&(pVal->validityDuration)), pBitStrm, pErrCode);
	                                                } else {
	                                                    pVal->validityDuration = 600;
	                                                }
	                                                if (ret) {
	                                                    /*Decode transmissionInterval */
	                                                    if (pVal->exist.transmissionInterval) {
	                                                    	ret = V2xFac_TransmissionIntervalType_Decode((&(pVal->transmissionInterval)), pBitStrm, pErrCode);
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode stationType */
	                                                        ret = V2xFac_StationTypeType_Decode((&(pVal->stationType)), pBitStrm, pErrCode);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_ManagementContainerType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DenMsgType_Initialize(V2xFac_DenMsgType* pVal)
{
	(void)pVal;



	/*set management */
	V2xFac_ManagementContainerType_Initialize((&(pVal->management)));
	/*set situation */
	pVal->exist.situation = 1;
	V2xFac_SituationContainerType_Initialize((&(pVal->situation)));
	/*set location */
	pVal->exist.location = 1;
	V2xFac_LocationContainerType_Initialize((&(pVal->location)));
	/*set alacarte */
	pVal->exist.alacarte = 1;
	V2xFac_AlacarteContainerType_Initialize((&(pVal->alacarte)));
}

flag V2xFac_DenMsgType_IsConstraintValid(const V2xFac_DenMsgType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ManagementContainerType_IsConstraintValid((&(pVal->management)), pErrCode);
    if (ret) {
        if (pVal->exist.situation) {
        	ret = V2xFac_SituationContainerType_IsConstraintValid((&(pVal->situation)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.location) {
            	ret = V2xFac_LocationContainerType_IsConstraintValid((&(pVal->location)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.alacarte) {
                	ret = V2xFac_AlacarteContainerType_IsConstraintValid((&(pVal->alacarte)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag V2xFac_DenMsgType_Encode(const V2xFac_DenMsgType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DenMsgType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.situation);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.location);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.alacarte);
	            if (ret) {
	                /*Encode management */
	                ret = V2xFac_ManagementContainerType_Encode((&(pVal->management)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode situation */
	                    if (pVal->exist.situation) {
	                    	ret = V2xFac_SituationContainerType_Encode((&(pVal->situation)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode location */
	                        if (pVal->exist.location) {
	                        	ret = V2xFac_LocationContainerType_Encode((&(pVal->location)), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode alacarte */
	                            if (pVal->exist.alacarte) {
	                            	ret = V2xFac_AlacarteContainerType_Encode((&(pVal->alacarte)), pBitStrm, pErrCode, FALSE);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DenMsgType_Decode(V2xFac_DenMsgType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.situation = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DENMSGTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.location = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DENMSGTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.alacarte = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_DENMSGTYPE;
	        if (ret) {
	            /*Decode management */
	            ret = V2xFac_ManagementContainerType_Decode((&(pVal->management)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode situation */
	                if (pVal->exist.situation) {
	                	ret = V2xFac_SituationContainerType_Decode((&(pVal->situation)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode location */
	                    if (pVal->exist.location) {
	                    	ret = V2xFac_LocationContainerType_Decode((&(pVal->location)), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode alacarte */
	                        if (pVal->exist.alacarte) {
	                        	ret = V2xFac_AlacarteContainerType_Decode((&(pVal->alacarte)), pBitStrm, pErrCode);
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_DenMsgType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_DenmMessageRootType_Initialize(V2xFac_DenmMessageRootType* pVal)
{
	(void)pVal;



	/*set itsPduHeader */
	V2xFac_ItsPduHeaderType_Initialize((&(pVal->itsPduHeader)));
	/*set denm */
	V2xFac_DenMsgType_Initialize((&(pVal->denm)));
}

flag V2xFac_DenmMessageRootType_IsConstraintValid(const V2xFac_DenmMessageRootType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ItsPduHeaderType_IsConstraintValid((&(pVal->itsPduHeader)), pErrCode);
    if (ret) {
        ret = V2xFac_DenMsgType_IsConstraintValid((&(pVal->denm)), pErrCode);
    }

	return ret;
}

flag V2xFac_DenmMessageRootType_Encode(const V2xFac_DenmMessageRootType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DenmMessageRootType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode itsPduHeader */
	    ret = V2xFac_ItsPduHeaderType_Encode((&(pVal->itsPduHeader)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode denm */
	        ret = V2xFac_DenMsgType_Encode((&(pVal->denm)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DenmMessageRootType_Decode(V2xFac_DenmMessageRootType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode itsPduHeader */
	ret = V2xFac_ItsPduHeaderType_Decode((&(pVal->itsPduHeader)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode denm */
	    ret = V2xFac_DenMsgType_Decode((&(pVal->denm)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_DenmMessageRootType_IsConstraintValid(pVal, pErrCode);
}

