/*
	Code automatically generated by asn1scc tool.
	Edited by Sayed Badr:
	 * 1- Commenting all decleared global variables. */
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt.h"
#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "CAM.h"


void V2xFac_PublicTransportContainerType_Initialize(V2xFac_PublicTransportContainerType* pVal)
{
	(void)pVal;



	/*set embarkationStatus */
	V2xFac_EmbarkationStatusType_Initialize((&(pVal->embarkationStatus)));
	/*set ptActivation */
	pVal->exist.ptActivation = 1;
	V2xFac_PtActivationType_Initialize((&(pVal->ptActivation)));
}

flag V2xFac_PublicTransportContainerType_IsConstraintValid(const V2xFac_PublicTransportContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_EmbarkationStatusType_IsConstraintValid((&(pVal->embarkationStatus)), pErrCode);
    if (ret) {
        if (pVal->exist.ptActivation) {
        	ret = V2xFac_PtActivationType_IsConstraintValid((&(pVal->ptActivation)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_PublicTransportContainerType_Encode(const V2xFac_PublicTransportContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_PublicTransportContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.ptActivation);
	    if (ret) {
	        /*Encode embarkationStatus */
	        ret = V2xFac_EmbarkationStatusType_Encode((&(pVal->embarkationStatus)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ptActivation */
	            if (pVal->exist.ptActivation) {
	            	ret = V2xFac_PtActivationType_Encode((&(pVal->ptActivation)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_PublicTransportContainerType_Decode(V2xFac_PublicTransportContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.ptActivation = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_PUBLICTRANSPORTCONTAINERTYPE;
	if (ret) {
	    /*Decode embarkationStatus */
	    ret = V2xFac_EmbarkationStatusType_Decode((&(pVal->embarkationStatus)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ptActivation */
	        if (pVal->exist.ptActivation) {
	        	ret = V2xFac_PtActivationType_Decode((&(pVal->ptActivation)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && V2xFac_PublicTransportContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_BasicContainerType_Initialize(V2xFac_BasicContainerType* pVal)
{
	(void)pVal;



	/*set stationType */
	V2xFac_StationTypeType_Initialize((&(pVal->stationType)));
	/*set referencePosition */
	V2xFac_ReferencePositionType_Initialize((&(pVal->referencePosition)));
}

flag V2xFac_BasicContainerType_IsConstraintValid(const V2xFac_BasicContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_StationTypeType_IsConstraintValid((&(pVal->stationType)), pErrCode);
    if (ret) {
        ret = V2xFac_ReferencePositionType_IsConstraintValid((&(pVal->referencePosition)), pErrCode);
    }

	return ret;
}

flag V2xFac_BasicContainerType_Encode(const V2xFac_BasicContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_BasicContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode stationType */
	    ret = V2xFac_StationTypeType_Encode((&(pVal->stationType)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode referencePosition */
	        ret = V2xFac_ReferencePositionType_Encode((&(pVal->referencePosition)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_BasicContainerType_Decode(V2xFac_BasicContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode stationType */
	ret = V2xFac_StationTypeType_Decode((&(pVal->stationType)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode referencePosition */
	    ret = V2xFac_ReferencePositionType_Decode((&(pVal->referencePosition)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_BasicContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_DangerousGoodsContainerType_Initialize(V2xFac_DangerousGoodsContainerType* pVal)
{
	(void)pVal;



	/*set dangerousGoodsBasic */
	V2xFac_DangerousGoodsBasicType_Initialize((&(pVal->dangerousGoodsBasic)));
}

flag V2xFac_DangerousGoodsContainerType_IsConstraintValid(const V2xFac_DangerousGoodsContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_DangerousGoodsBasicType_IsConstraintValid((&(pVal->dangerousGoodsBasic)), pErrCode);

	return ret;
}

flag V2xFac_DangerousGoodsContainerType_Encode(const V2xFac_DangerousGoodsContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_DangerousGoodsContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode dangerousGoodsBasic */
	    ret = V2xFac_DangerousGoodsBasicType_Encode((&(pVal->dangerousGoodsBasic)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_DangerousGoodsContainerType_Decode(V2xFac_DangerousGoodsContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode dangerousGoodsBasic */
	ret = V2xFac_DangerousGoodsBasicType_Decode((&(pVal->dangerousGoodsBasic)), pBitStrm, pErrCode);

	return ret  && V2xFac_DangerousGoodsContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_SpecialTransportContainerType_Initialize(V2xFac_SpecialTransportContainerType* pVal)
{
	(void)pVal;



	/*set specialTransportType */
	V2xFac_SpecialTransportTypeType_Initialize((&(pVal->specialTransportType)));
	/*set lightBarSirenInUse */
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
}

flag V2xFac_SpecialTransportContainerType_IsConstraintValid(const V2xFac_SpecialTransportContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_SpecialTransportTypeType_IsConstraintValid((&(pVal->specialTransportType)), pErrCode);
    if (ret) {
        ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);
    }

	return ret;
}

flag V2xFac_SpecialTransportContainerType_Encode(const V2xFac_SpecialTransportContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpecialTransportContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode specialTransportType */
	    ret = V2xFac_SpecialTransportTypeType_Encode((&(pVal->specialTransportType)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lightBarSirenInUse */
	        ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpecialTransportContainerType_Decode(V2xFac_SpecialTransportContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode specialTransportType */
	ret = V2xFac_SpecialTransportTypeType_Decode((&(pVal->specialTransportType)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lightBarSirenInUse */
	    ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_SpecialTransportContainerType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RoadWorksContainerBasicType_Initialize(V2xFac_RoadWorksContainerBasicType* pVal)
{
	(void)pVal;



	/*set roadworksSubCauseCode */
	pVal->exist.roadworksSubCauseCode = 1;
	V2xFac_RoadworksSubCauseCodeType_Initialize((&(pVal->roadworksSubCauseCode)));
	/*set lightBarSirenInUse */
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
	/*set closedLanes */
	pVal->exist.closedLanes = 1;
	V2xFac_ClosedLanesType_Initialize((&(pVal->closedLanes)));
}

flag V2xFac_RoadWorksContainerBasicType_IsConstraintValid(const V2xFac_RoadWorksContainerBasicType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.roadworksSubCauseCode) {
    	ret = V2xFac_RoadworksSubCauseCodeType_IsConstraintValid((&(pVal->roadworksSubCauseCode)), pErrCode);
    }
    if (ret) {
        ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);
        if (ret) {
            if (pVal->exist.closedLanes) {
            	ret = V2xFac_ClosedLanesType_IsConstraintValid((&(pVal->closedLanes)), pErrCode);
            }
        }
    }

	return ret;
}

flag V2xFac_RoadWorksContainerBasicType_Encode(const V2xFac_RoadWorksContainerBasicType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RoadWorksContainerBasicType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.roadworksSubCauseCode);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.closedLanes);
	        if (ret) {
	            /*Encode roadworksSubCauseCode */
	            if (pVal->exist.roadworksSubCauseCode) {
	            	ret = V2xFac_RoadworksSubCauseCodeType_Encode((&(pVal->roadworksSubCauseCode)), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode lightBarSirenInUse */
	                ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode closedLanes */
	                    if (pVal->exist.closedLanes) {
	                    	ret = V2xFac_ClosedLanesType_Encode((&(pVal->closedLanes)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RoadWorksContainerBasicType_Decode(V2xFac_RoadWorksContainerBasicType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.roadworksSubCauseCode = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINERBASICTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.closedLanes = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_ROADWORKSCONTAINERBASICTYPE;
	    if (ret) {
	        /*Decode roadworksSubCauseCode */
	        if (pVal->exist.roadworksSubCauseCode) {
	        	ret = V2xFac_RoadworksSubCauseCodeType_Decode((&(pVal->roadworksSubCauseCode)), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode lightBarSirenInUse */
	            ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode closedLanes */
	                if (pVal->exist.closedLanes) {
	                	ret = V2xFac_ClosedLanesType_Decode((&(pVal->closedLanes)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_RoadWorksContainerBasicType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_RescueContainerType_Initialize(V2xFac_RescueContainerType* pVal)
{
	(void)pVal;



	/*set lightBarSirenInUse */
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
}

flag V2xFac_RescueContainerType_IsConstraintValid(const V2xFac_RescueContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);

	return ret;
}

flag V2xFac_RescueContainerType_Encode(const V2xFac_RescueContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RescueContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode lightBarSirenInUse */
	    ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RescueContainerType_Decode(V2xFac_RescueContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode lightBarSirenInUse */
	ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);

	return ret  && V2xFac_RescueContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_SafetyCarContainerType_Initialize(V2xFac_SafetyCarContainerType* pVal)
{
	(void)pVal;



	/*set lightBarSirenInUse */
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
	/*set incidentIndication */
	pVal->exist.incidentIndication = 1;
	V2xFac_CauseCodeType_Initialize((&(pVal->incidentIndication)));
	/*set trafficRule */
	pVal->exist.trafficRule = 1;
	V2xFac_TrafficRuleType_Initialize((&(pVal->trafficRule)));
	/*set speedLimit */
	pVal->exist.speedLimit = 1;
	V2xFac_SpeedLimitType_Initialize((&(pVal->speedLimit)));
}

flag V2xFac_SafetyCarContainerType_IsConstraintValid(const V2xFac_SafetyCarContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);
    if (ret) {
        if (pVal->exist.incidentIndication) {
        	ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->incidentIndication)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.trafficRule) {
            	ret = V2xFac_TrafficRuleType_IsConstraintValid((&(pVal->trafficRule)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.speedLimit) {
                	ret = V2xFac_SpeedLimitType_IsConstraintValid((&(pVal->speedLimit)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag V2xFac_SafetyCarContainerType_Encode(const V2xFac_SafetyCarContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SafetyCarContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.incidentIndication);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.trafficRule);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.speedLimit);
	            if (ret) {
	                /*Encode lightBarSirenInUse */
	                ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode incidentIndication */
	                    if (pVal->exist.incidentIndication) {
	                    	ret = V2xFac_CauseCodeType_Encode((&(pVal->incidentIndication)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode trafficRule */
	                        if (pVal->exist.trafficRule) {
	                        	ret = V2xFac_TrafficRuleType_Encode((&(pVal->trafficRule)), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode speedLimit */
	                            if (pVal->exist.speedLimit) {
	                            	ret = V2xFac_SpeedLimitType_Encode((&(pVal->speedLimit)), pBitStrm, pErrCode, FALSE);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SafetyCarContainerType_Decode(V2xFac_SafetyCarContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.incidentIndication = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SAFETYCARCONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.trafficRule = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SAFETYCARCONTAINERTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.speedLimit = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SAFETYCARCONTAINERTYPE;
	        if (ret) {
	            /*Decode lightBarSirenInUse */
	            ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode incidentIndication */
	                if (pVal->exist.incidentIndication) {
	                	ret = V2xFac_CauseCodeType_Decode((&(pVal->incidentIndication)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode trafficRule */
	                    if (pVal->exist.trafficRule) {
	                    	ret = V2xFac_TrafficRuleType_Decode((&(pVal->trafficRule)), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode speedLimit */
	                        if (pVal->exist.speedLimit) {
	                        	ret = V2xFac_SpeedLimitType_Decode((&(pVal->speedLimit)), pBitStrm, pErrCode);
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_SafetyCarContainerType_IsConstraintValid(pVal, pErrCode);
}


void V2xFac_EmergencyContainerType_Initialize(V2xFac_EmergencyContainerType* pVal)
{
	(void)pVal;



	/*set lightBarSirenInUse */
	V2xFac_LightBarSirenInUseType_Initialize((&(pVal->lightBarSirenInUse)));
	/*set incidentIndication */
	pVal->exist.incidentIndication = 1;
	V2xFac_CauseCodeType_Initialize((&(pVal->incidentIndication)));
	/*set emergencyPriority */
	pVal->exist.emergencyPriority = 1;
	V2xFac_EmergencyPriorityType_Initialize((&(pVal->emergencyPriority)));
}

flag V2xFac_EmergencyContainerType_IsConstraintValid(const V2xFac_EmergencyContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_LightBarSirenInUseType_IsConstraintValid((&(pVal->lightBarSirenInUse)), pErrCode);
    if (ret) {
        if (pVal->exist.incidentIndication) {
        	ret = V2xFac_CauseCodeType_IsConstraintValid((&(pVal->incidentIndication)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.emergencyPriority) {
            	ret = V2xFac_EmergencyPriorityType_IsConstraintValid((&(pVal->emergencyPriority)), pErrCode);
            }
        }
    }

	return ret;
}

flag V2xFac_EmergencyContainerType_Encode(const V2xFac_EmergencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_EmergencyContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.incidentIndication);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.emergencyPriority);
	        if (ret) {
	            /*Encode lightBarSirenInUse */
	            ret = V2xFac_LightBarSirenInUseType_Encode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode incidentIndication */
	                if (pVal->exist.incidentIndication) {
	                	ret = V2xFac_CauseCodeType_Encode((&(pVal->incidentIndication)), pBitStrm, pErrCode, FALSE);
	                }
	                if (ret) {
	                    /*Encode emergencyPriority */
	                    if (pVal->exist.emergencyPriority) {
	                    	ret = V2xFac_EmergencyPriorityType_Encode((&(pVal->emergencyPriority)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_EmergencyContainerType_Decode(V2xFac_EmergencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.incidentIndication = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EMERGENCYCONTAINERTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.emergencyPriority = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_EMERGENCYCONTAINERTYPE;
	    if (ret) {
	        /*Decode lightBarSirenInUse */
	        ret = V2xFac_LightBarSirenInUseType_Decode((&(pVal->lightBarSirenInUse)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode incidentIndication */
	            if (pVal->exist.incidentIndication) {
	            	ret = V2xFac_CauseCodeType_Decode((&(pVal->incidentIndication)), pBitStrm, pErrCode);
	            }
	            if (ret) {
	                /*Decode emergencyPriority */
	                if (pVal->exist.emergencyPriority) {
	                	ret = V2xFac_EmergencyPriorityType_Decode((&(pVal->emergencyPriority)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_EmergencyContainerType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_SpecialVehicleContainerType_Initialize(V2xFac_SpecialVehicleContainerType* pVal)
{
	(void)pVal;


	/*set publicTransportContainer*/
	pVal->kind = publicTransportContainer_PRESENT;
	V2xFac_PublicTransportContainerType_Initialize((&(pVal->u.publicTransportContainer)));
}

flag V2xFac_SpecialVehicleContainerType_IsConstraintValid(const V2xFac_SpecialVehicleContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == publicTransportContainer_PRESENT) {
    	ret = V2xFac_PublicTransportContainerType_IsConstraintValid((&(pVal->u.publicTransportContainer)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == specialTransportContainer_PRESENT) {
        	ret = V2xFac_SpecialTransportContainerType_IsConstraintValid((&(pVal->u.specialTransportContainer)), pErrCode);
        }
        if (ret) {
            if (pVal->kind == dangerousGoodsContainer_PRESENT) {
            	ret = V2xFac_DangerousGoodsContainerType_IsConstraintValid((&(pVal->u.dangerousGoodsContainer)), pErrCode);
            }
            if (ret) {
                if (pVal->kind == roadWorksContainerBasic_PRESENT) {
                	ret = V2xFac_RoadWorksContainerBasicType_IsConstraintValid((&(pVal->u.roadWorksContainerBasic)), pErrCode);
                }
                if (ret) {
                    if (pVal->kind == rescueContainer_PRESENT) {
                    	ret = V2xFac_RescueContainerType_IsConstraintValid((&(pVal->u.rescueContainer)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->kind == emergencyContainer_PRESENT) {
                        	ret = V2xFac_EmergencyContainerType_IsConstraintValid((&(pVal->u.emergencyContainer)), pErrCode);
                        }
                        if (ret) {
                            if (pVal->kind == safetyCarContainer_PRESENT) {
                            	ret = V2xFac_SafetyCarContainerType_IsConstraintValid((&(pVal->u.safetyCarContainer)), pErrCode);
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_SpecialVehicleContainerType_Encode(const V2xFac_SpecialVehicleContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_SpecialVehicleContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case publicTransportContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	    	ret = V2xFac_PublicTransportContainerType_Encode((&(pVal->u.publicTransportContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case specialTransportContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	    	ret = V2xFac_SpecialTransportContainerType_Encode((&(pVal->u.specialTransportContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case dangerousGoodsContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	    	ret = V2xFac_DangerousGoodsContainerType_Encode((&(pVal->u.dangerousGoodsContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case roadWorksContainerBasic_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	    	ret = V2xFac_RoadWorksContainerBasicType_Encode((&(pVal->u.roadWorksContainerBasic)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case rescueContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	    	ret = V2xFac_RescueContainerType_Encode((&(pVal->u.rescueContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case emergencyContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	    	ret = V2xFac_EmergencyContainerType_Encode((&(pVal->u.emergencyContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case safetyCarContainer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	    	ret = V2xFac_SafetyCarContainerType_Encode((&(pVal->u.safetyCarContainer)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_V2XFAC_SPECIALVEHICLECONTAINERTYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_SpecialVehicleContainerType_Decode(V2xFac_SpecialVehicleContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint V2xFac_SpecialVehicleContainerType_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &V2xFac_SpecialVehicleContainerType_index_tmp, 0, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_SPECIALVEHICLECONTAINERTYPE;
	if (ret) {
	    switch(V2xFac_SpecialVehicleContainerType_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = publicTransportContainer_PRESENT;
	    	ret = V2xFac_PublicTransportContainerType_Decode((&(pVal->u.publicTransportContainer)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = specialTransportContainer_PRESENT;
	    	ret = V2xFac_SpecialTransportContainerType_Decode((&(pVal->u.specialTransportContainer)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = dangerousGoodsContainer_PRESENT;
	    	ret = V2xFac_DangerousGoodsContainerType_Decode((&(pVal->u.dangerousGoodsContainer)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = roadWorksContainerBasic_PRESENT;
	    	ret = V2xFac_RoadWorksContainerBasicType_Decode((&(pVal->u.roadWorksContainerBasic)), pBitStrm, pErrCode);
	    	break;
	    case 4:
	    	pVal->kind = rescueContainer_PRESENT;
	    	ret = V2xFac_RescueContainerType_Decode((&(pVal->u.rescueContainer)), pBitStrm, pErrCode);
	    	break;
	    case 5:
	    	pVal->kind = emergencyContainer_PRESENT;
	    	ret = V2xFac_EmergencyContainerType_Decode((&(pVal->u.emergencyContainer)), pBitStrm, pErrCode);
	    	break;
	    case 6:
	    	pVal->kind = safetyCarContainer_PRESENT;
	    	ret = V2xFac_SafetyCarContainerType_Decode((&(pVal->u.safetyCarContainer)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_V2XFAC_SPECIALVEHICLECONTAINERTYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && V2xFac_SpecialVehicleContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_BasicVehicleContainerLowFrequencyType_Initialize(V2xFac_BasicVehicleContainerLowFrequencyType* pVal)
{
	(void)pVal;



	/*set vehicleRole */
	V2xFac_VehicleRoleType_Initialize((&(pVal->vehicleRole)));
	/*set exteriorLights */
	V2xFac_ExteriorLightsType_Initialize((&(pVal->exteriorLights)));
	/*set pathHistory */
	V2xFac_PathHistoryType_Initialize((&(pVal->pathHistory)));
}

flag V2xFac_BasicVehicleContainerLowFrequencyType_IsConstraintValid(const V2xFac_BasicVehicleContainerLowFrequencyType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_VehicleRoleType_IsConstraintValid((&(pVal->vehicleRole)), pErrCode);
    if (ret) {
        ret = V2xFac_ExteriorLightsType_IsConstraintValid((&(pVal->exteriorLights)), pErrCode);
        if (ret) {
            ret = V2xFac_PathHistoryType_IsConstraintValid((&(pVal->pathHistory)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_BasicVehicleContainerLowFrequencyType_Encode(const V2xFac_BasicVehicleContainerLowFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_BasicVehicleContainerLowFrequencyType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vehicleRole */
	    ret = V2xFac_VehicleRoleType_Encode((&(pVal->vehicleRole)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode exteriorLights */
	        ret = V2xFac_ExteriorLightsType_Encode((&(pVal->exteriorLights)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode pathHistory */
	            ret = V2xFac_PathHistoryType_Encode((&(pVal->pathHistory)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_BasicVehicleContainerLowFrequencyType_Decode(V2xFac_BasicVehicleContainerLowFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode vehicleRole */
	ret = V2xFac_VehicleRoleType_Decode((&(pVal->vehicleRole)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode exteriorLights */
	    ret = V2xFac_ExteriorLightsType_Decode((&(pVal->exteriorLights)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode pathHistory */
	        ret = V2xFac_PathHistoryType_Decode((&(pVal->pathHistory)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_BasicVehicleContainerLowFrequencyType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_LowFrequencyContainerType_Initialize(V2xFac_LowFrequencyContainerType* pVal)
{
	(void)pVal;


	/*set basicVehicleContainerLowFrequency*/
	pVal->kind = basicVehicleContainerLowFrequency_PRESENT;
	V2xFac_BasicVehicleContainerLowFrequencyType_Initialize((&(pVal->u.basicVehicleContainerLowFrequency)));
}

flag V2xFac_LowFrequencyContainerType_IsConstraintValid(const V2xFac_LowFrequencyContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == basicVehicleContainerLowFrequency_PRESENT) {
    	ret = V2xFac_BasicVehicleContainerLowFrequencyType_IsConstraintValid((&(pVal->u.basicVehicleContainerLowFrequency)), pErrCode);
    }

	return ret;
}

flag V2xFac_LowFrequencyContainerType_Encode(const V2xFac_LowFrequencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_LowFrequencyContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case basicVehicleContainerLowFrequency_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	    	ret = V2xFac_BasicVehicleContainerLowFrequencyType_Encode((&(pVal->u.basicVehicleContainerLowFrequency)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_V2XFAC_LOWFREQUENCYCONTAINERTYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_LowFrequencyContainerType_Decode(V2xFac_LowFrequencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint V2xFac_LowFrequencyContainerType_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &V2xFac_LowFrequencyContainerType_index_tmp, 0, 0);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_LOWFREQUENCYCONTAINERTYPE;
	if (ret) {
	    switch(V2xFac_LowFrequencyContainerType_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = basicVehicleContainerLowFrequency_PRESENT;
	    	ret = V2xFac_BasicVehicleContainerLowFrequencyType_Decode((&(pVal->u.basicVehicleContainerLowFrequency)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_V2XFAC_LOWFREQUENCYCONTAINERTYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && V2xFac_LowFrequencyContainerType_IsConstraintValid(pVal, pErrCode);
}

void V2xFac_RSUContainerHighFrequencyType_Initialize(V2xFac_RSUContainerHighFrequencyType* pVal)
{
	(void)pVal;



	/*set protectedCommunicationZonesRSU */
	pVal->exist.protectedCommunicationZonesRSU = 1;
	V2xFac_ProtectedCommunicationZonesRSUType_Initialize((&(pVal->protectedCommunicationZonesRSU)));
}

flag V2xFac_RSUContainerHighFrequencyType_IsConstraintValid(const V2xFac_RSUContainerHighFrequencyType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.protectedCommunicationZonesRSU) {
    	ret = V2xFac_ProtectedCommunicationZonesRSUType_IsConstraintValid((&(pVal->protectedCommunicationZonesRSU)), pErrCode);
    }

	return ret;
}

flag V2xFac_RSUContainerHighFrequencyType_Encode(const V2xFac_RSUContainerHighFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_RSUContainerHighFrequencyType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.protectedCommunicationZonesRSU);
	    if (ret) {
	        /*Encode protectedCommunicationZonesRSU */
	        if (pVal->exist.protectedCommunicationZonesRSU) {
	        	ret = V2xFac_ProtectedCommunicationZonesRSUType_Encode((&(pVal->protectedCommunicationZonesRSU)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_RSUContainerHighFrequencyType_Decode(V2xFac_RSUContainerHighFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.protectedCommunicationZonesRSU = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_RSUCONTAINERHIGHFREQUENCYTYPE;
	if (ret) {
	    /*Decode protectedCommunicationZonesRSU */
	    if (pVal->exist.protectedCommunicationZonesRSU) {
	    	ret = V2xFac_ProtectedCommunicationZonesRSUType_Decode((&(pVal->protectedCommunicationZonesRSU)), pBitStrm, pErrCode);
	    }
	}

	return ret  && V2xFac_RSUContainerHighFrequencyType_IsConstraintValid(pVal, pErrCode);
}


void V2xFac_BasicVehicleContainerHighFrequencyType_Initialize(V2xFac_BasicVehicleContainerHighFrequencyType* pVal)
{
	(void)pVal;



	/*set heading */
	V2xFac_HeadingType_Initialize((&(pVal->heading)));
	/*set speed */
	V2xFac_SpeedType_Initialize((&(pVal->speed)));
	/*set driveDirection */
	V2xFac_DriveDirectionType_Initialize((&(pVal->driveDirection)));
	/*set vehicleLength */
	V2xFac_VehicleLengthType_Initialize((&(pVal->vehicleLength)));
	/*set vehicleWidth */
	V2xFac_VehicleWidthType_Initialize((&(pVal->vehicleWidth)));
	/*set longitudinalAcceleration */
	V2xFac_LongitudinalAccelerationType_Initialize((&(pVal->longitudinalAcceleration)));
	/*set curvature */
	V2xFac_CurvatureType_Initialize((&(pVal->curvature)));
	/*set curvatureCalculationMode */
	V2xFac_CurvatureCalculationModeType_Initialize((&(pVal->curvatureCalculationMode)));
	/*set yawRate */
	V2xFac_YawRateType_Initialize((&(pVal->yawRate)));
	/*set accelerationControl */
	pVal->exist.accelerationControl = 1;
	V2xFac_AccelerationControlType_Initialize((&(pVal->accelerationControl)));
	/*set lanePosition */
	pVal->exist.lanePosition = 1;
	V2xFac_LanePositionType_Initialize((&(pVal->lanePosition)));
	/*set steeringWheelAngle */
	pVal->exist.steeringWheelAngle = 1;
	V2xFac_SteeringWheelAngleType_Initialize((&(pVal->steeringWheelAngle)));
	/*set lateralAcceleration */
	pVal->exist.lateralAcceleration = 1;
	V2xFac_LateralAccelerationType_Initialize((&(pVal->lateralAcceleration)));
	/*set verticalAcceleration */
	pVal->exist.verticalAcceleration = 1;
	V2xFac_VerticalAccelerationType_Initialize((&(pVal->verticalAcceleration)));
	/*set performanceClass */
	pVal->exist.performanceClass = 1;
	V2xFac_PerformanceClassType_Initialize((&(pVal->performanceClass)));
	/*set cenDsrcTollingZone */
	pVal->exist.cenDsrcTollingZone = 1;
	V2xFac_CenDsrcTollingZoneType_Initialize((&(pVal->cenDsrcTollingZone)));
}

flag V2xFac_BasicVehicleContainerHighFrequencyType_IsConstraintValid(const V2xFac_BasicVehicleContainerHighFrequencyType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_HeadingType_IsConstraintValid((&(pVal->heading)), pErrCode);
    if (ret) {
        ret = V2xFac_SpeedType_IsConstraintValid((&(pVal->speed)), pErrCode);
        if (ret) {
            ret = V2xFac_DriveDirectionType_IsConstraintValid((&(pVal->driveDirection)), pErrCode);
            if (ret) {
                ret = V2xFac_VehicleLengthType_IsConstraintValid((&(pVal->vehicleLength)), pErrCode);
                if (ret) {
                    ret = V2xFac_VehicleWidthType_IsConstraintValid((&(pVal->vehicleWidth)), pErrCode);
                    if (ret) {
                        ret = V2xFac_LongitudinalAccelerationType_IsConstraintValid((&(pVal->longitudinalAcceleration)), pErrCode);
                        if (ret) {
                            ret = V2xFac_CurvatureType_IsConstraintValid((&(pVal->curvature)), pErrCode);
                            if (ret) {
                                ret = V2xFac_CurvatureCalculationModeType_IsConstraintValid((&(pVal->curvatureCalculationMode)), pErrCode);
                                if (ret) {
                                    ret = V2xFac_YawRateType_IsConstraintValid((&(pVal->yawRate)), pErrCode);
                                    if (ret) {
                                        if (pVal->exist.accelerationControl) {
                                        	ret = V2xFac_AccelerationControlType_IsConstraintValid((&(pVal->accelerationControl)), pErrCode);
                                        }
                                        if (ret) {
                                            if (pVal->exist.lanePosition) {
                                            	ret = V2xFac_LanePositionType_IsConstraintValid((&(pVal->lanePosition)), pErrCode);
                                            }
                                            if (ret) {
                                                if (pVal->exist.steeringWheelAngle) {
                                                	ret = V2xFac_SteeringWheelAngleType_IsConstraintValid((&(pVal->steeringWheelAngle)), pErrCode);
                                                }
                                                if (ret) {
                                                    if (pVal->exist.lateralAcceleration) {
                                                    	ret = V2xFac_LateralAccelerationType_IsConstraintValid((&(pVal->lateralAcceleration)), pErrCode);
                                                    }
                                                    if (ret) {
                                                        if (pVal->exist.verticalAcceleration) {
                                                        	ret = V2xFac_VerticalAccelerationType_IsConstraintValid((&(pVal->verticalAcceleration)), pErrCode);
                                                        }
                                                        if (ret) {
                                                            if (pVal->exist.performanceClass) {
                                                            	ret = V2xFac_PerformanceClassType_IsConstraintValid((&(pVal->performanceClass)), pErrCode);
                                                            }
                                                            if (ret) {
                                                                if (pVal->exist.cenDsrcTollingZone) {
                                                                	ret = V2xFac_CenDsrcTollingZoneType_IsConstraintValid((&(pVal->cenDsrcTollingZone)), pErrCode);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag V2xFac_BasicVehicleContainerHighFrequencyType_Encode(const V2xFac_BasicVehicleContainerHighFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_BasicVehicleContainerHighFrequencyType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.accelerationControl);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.lanePosition);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.steeringWheelAngle);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.lateralAcceleration);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.verticalAcceleration);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.performanceClass);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.cenDsrcTollingZone);
	                            if (ret) {
	                                /*Encode heading */
	                                ret = V2xFac_HeadingType_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode speed */
	                                    ret = V2xFac_SpeedType_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode driveDirection */
	                                        ret = V2xFac_DriveDirectionType_Encode((&(pVal->driveDirection)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode vehicleLength */
	                                            ret = V2xFac_VehicleLengthType_Encode((&(pVal->vehicleLength)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode vehicleWidth */
	                                                ret = V2xFac_VehicleWidthType_Encode((&(pVal->vehicleWidth)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode longitudinalAcceleration */
	                                                    ret = V2xFac_LongitudinalAccelerationType_Encode((&(pVal->longitudinalAcceleration)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode curvature */
	                                                        ret = V2xFac_CurvatureType_Encode((&(pVal->curvature)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode curvatureCalculationMode */
	                                                            ret = V2xFac_CurvatureCalculationModeType_Encode((&(pVal->curvatureCalculationMode)), pBitStrm, pErrCode, FALSE);
	                                                            if (ret) {
	                                                                /*Encode yawRate */
	                                                                ret = V2xFac_YawRateType_Encode((&(pVal->yawRate)), pBitStrm, pErrCode, FALSE);
	                                                                if (ret) {
	                                                                    /*Encode accelerationControl */
	                                                                    if (pVal->exist.accelerationControl) {
	                                                                    	ret = V2xFac_AccelerationControlType_Encode((&(pVal->accelerationControl)), pBitStrm, pErrCode, FALSE);
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode lanePosition */
	                                                                        if (pVal->exist.lanePosition) {
	                                                                        	ret = V2xFac_LanePositionType_Encode((&(pVal->lanePosition)), pBitStrm, pErrCode, FALSE);
	                                                                        }
	                                                                        if (ret) {
	                                                                            /*Encode steeringWheelAngle */
	                                                                            if (pVal->exist.steeringWheelAngle) {
	                                                                            	ret = V2xFac_SteeringWheelAngleType_Encode((&(pVal->steeringWheelAngle)), pBitStrm, pErrCode, FALSE);
	                                                                            }
	                                                                            if (ret) {
	                                                                                /*Encode lateralAcceleration */
	                                                                                if (pVal->exist.lateralAcceleration) {
	                                                                                	ret = V2xFac_LateralAccelerationType_Encode((&(pVal->lateralAcceleration)), pBitStrm, pErrCode, FALSE);
	                                                                                }
	                                                                                if (ret) {
	                                                                                    /*Encode verticalAcceleration */
	                                                                                    if (pVal->exist.verticalAcceleration) {
	                                                                                    	ret = V2xFac_VerticalAccelerationType_Encode((&(pVal->verticalAcceleration)), pBitStrm, pErrCode, FALSE);
	                                                                                    }
	                                                                                    if (ret) {
	                                                                                        /*Encode performanceClass */
	                                                                                        if (pVal->exist.performanceClass) {
	                                                                                        	ret = V2xFac_PerformanceClassType_Encode((&(pVal->performanceClass)), pBitStrm, pErrCode, FALSE);
	                                                                                        }
	                                                                                        if (ret) {
	                                                                                            /*Encode cenDsrcTollingZone */
	                                                                                            if (pVal->exist.cenDsrcTollingZone) {
	                                                                                            	ret = V2xFac_CenDsrcTollingZoneType_Encode((&(pVal->cenDsrcTollingZone)), pBitStrm, pErrCode, FALSE);
	                                                                                            }
	                                                                                        }
	                                                                                    }
	                                                                                }
	                                                                            }
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_BasicVehicleContainerHighFrequencyType_Decode(V2xFac_BasicVehicleContainerHighFrequencyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.accelerationControl = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.lanePosition = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.steeringWheelAngle = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.lateralAcceleration = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.verticalAcceleration = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.performanceClass = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.cenDsrcTollingZone = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_BASICVEHICLECONTAINERHIGHFREQUENCYTYPE;
	                        if (ret) {
	                            /*Decode heading */
	                            ret = V2xFac_HeadingType_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode speed */
	                                ret = V2xFac_SpeedType_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode driveDirection */
	                                    ret = V2xFac_DriveDirectionType_Decode((&(pVal->driveDirection)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode vehicleLength */
	                                        ret = V2xFac_VehicleLengthType_Decode((&(pVal->vehicleLength)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode vehicleWidth */
	                                            ret = V2xFac_VehicleWidthType_Decode((&(pVal->vehicleWidth)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode longitudinalAcceleration */
	                                                ret = V2xFac_LongitudinalAccelerationType_Decode((&(pVal->longitudinalAcceleration)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode curvature */
	                                                    ret = V2xFac_CurvatureType_Decode((&(pVal->curvature)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode curvatureCalculationMode */
	                                                        ret = V2xFac_CurvatureCalculationModeType_Decode((&(pVal->curvatureCalculationMode)), pBitStrm, pErrCode);
	                                                        if (ret) {
	                                                            /*Decode yawRate */
	                                                            ret = V2xFac_YawRateType_Decode((&(pVal->yawRate)), pBitStrm, pErrCode);
	                                                            if (ret) {
	                                                                /*Decode accelerationControl */
	                                                                if (pVal->exist.accelerationControl) {
	                                                                	ret = V2xFac_AccelerationControlType_Decode((&(pVal->accelerationControl)), pBitStrm, pErrCode);
	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode lanePosition */
	                                                                    if (pVal->exist.lanePosition) {
	                                                                    	ret = V2xFac_LanePositionType_Decode((&(pVal->lanePosition)), pBitStrm, pErrCode);
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Decode steeringWheelAngle */
	                                                                        if (pVal->exist.steeringWheelAngle) {
	                                                                        	ret = V2xFac_SteeringWheelAngleType_Decode((&(pVal->steeringWheelAngle)), pBitStrm, pErrCode);
	                                                                        }
	                                                                        if (ret) {
	                                                                            /*Decode lateralAcceleration */
	                                                                            if (pVal->exist.lateralAcceleration) {
	                                                                            	ret = V2xFac_LateralAccelerationType_Decode((&(pVal->lateralAcceleration)), pBitStrm, pErrCode);
	                                                                            }
	                                                                            if (ret) {
	                                                                                /*Decode verticalAcceleration */
	                                                                                if (pVal->exist.verticalAcceleration) {
	                                                                                	ret = V2xFac_VerticalAccelerationType_Decode((&(pVal->verticalAcceleration)), pBitStrm, pErrCode);
	                                                                                }
	                                                                                if (ret) {
	                                                                                    /*Decode performanceClass */
	                                                                                    if (pVal->exist.performanceClass) {
	                                                                                    	ret = V2xFac_PerformanceClassType_Decode((&(pVal->performanceClass)), pBitStrm, pErrCode);
	                                                                                    }
	                                                                                    if (ret) {
	                                                                                        /*Decode cenDsrcTollingZone */
	                                                                                        if (pVal->exist.cenDsrcTollingZone) {
	                                                                                        	ret = V2xFac_CenDsrcTollingZoneType_Decode((&(pVal->cenDsrcTollingZone)), pBitStrm, pErrCode);
	                                                                                        }
	                                                                                    }
	                                                                                }
	                                                                            }
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_BasicVehicleContainerHighFrequencyType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_HighFrequencyContainerType_Initialize(V2xFac_HighFrequencyContainerType* pVal)
{
	(void)pVal;


	/*set basicVehicleContainerHighFrequency*/
	pVal->kind = basicVehicleContainerHighFrequency_PRESENT;
	V2xFac_BasicVehicleContainerHighFrequencyType_Initialize((&(pVal->u.basicVehicleContainerHighFrequency)));
}

flag V2xFac_HighFrequencyContainerType_IsConstraintValid(const V2xFac_HighFrequencyContainerType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == basicVehicleContainerHighFrequency_PRESENT) {
    	ret = V2xFac_BasicVehicleContainerHighFrequencyType_IsConstraintValid((&(pVal->u.basicVehicleContainerHighFrequency)), pErrCode);
    }
    if (ret) {
        if (pVal->kind == rsuContainerHighFrequency_PRESENT) {
        	ret = V2xFac_RSUContainerHighFrequencyType_IsConstraintValid((&(pVal->u.rsuContainerHighFrequency)), pErrCode);
        }
    }

	return ret;
}

flag V2xFac_HighFrequencyContainerType_Encode(const V2xFac_HighFrequencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_HighFrequencyContainerType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case basicVehicleContainerHighFrequency_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = V2xFac_BasicVehicleContainerHighFrequencyType_Encode((&(pVal->u.basicVehicleContainerHighFrequency)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case rsuContainerHighFrequency_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = V2xFac_RSUContainerHighFrequencyType_Encode((&(pVal->u.rsuContainerHighFrequency)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_V2XFAC_HIGHFREQUENCYCONTAINERTYPE;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_HighFrequencyContainerType_Decode(V2xFac_HighFrequencyContainerType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint V2xFac_HighFrequencyContainerType_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &V2xFac_HighFrequencyContainerType_index_tmp, 0, 1);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_HIGHFREQUENCYCONTAINERTYPE;
	if (ret) {
	    switch(V2xFac_HighFrequencyContainerType_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = basicVehicleContainerHighFrequency_PRESENT;
	    	ret = V2xFac_BasicVehicleContainerHighFrequencyType_Decode((&(pVal->u.basicVehicleContainerHighFrequency)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = rsuContainerHighFrequency_PRESENT;
	    	ret = V2xFac_RSUContainerHighFrequencyType_Decode((&(pVal->u.rsuContainerHighFrequency)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_V2XFAC_HIGHFREQUENCYCONTAINERTYPE;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && V2xFac_HighFrequencyContainerType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CamParametersType_Initialize(V2xFac_CamParametersType* pVal)
{
	(void)pVal;



	/*set basicContainer */
	V2xFac_BasicContainerType_Initialize((&(pVal->basicContainer)));
	/*set highFrequencyContainer */
	V2xFac_HighFrequencyContainerType_Initialize((&(pVal->highFrequencyContainer)));
	/*set lowFrequencyContainer */
	pVal->exist.lowFrequencyContainer = 1;
	V2xFac_LowFrequencyContainerType_Initialize((&(pVal->lowFrequencyContainer)));
	/*set specialVehicleContainer */
	pVal->exist.specialVehicleContainer = 1;
	V2xFac_SpecialVehicleContainerType_Initialize((&(pVal->specialVehicleContainer)));
}

flag V2xFac_CamParametersType_IsConstraintValid(const V2xFac_CamParametersType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_BasicContainerType_IsConstraintValid((&(pVal->basicContainer)), pErrCode);
    if (ret) {
        ret = V2xFac_HighFrequencyContainerType_IsConstraintValid((&(pVal->highFrequencyContainer)), pErrCode);
        if (ret) {
            if (pVal->exist.lowFrequencyContainer) {
            	ret = V2xFac_LowFrequencyContainerType_IsConstraintValid((&(pVal->lowFrequencyContainer)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.specialVehicleContainer) {
                	ret = V2xFac_SpecialVehicleContainerType_IsConstraintValid((&(pVal->specialVehicleContainer)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag V2xFac_CamParametersType_Encode(const V2xFac_CamParametersType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CamParametersType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.lowFrequencyContainer);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.specialVehicleContainer);
	        if (ret) {
	            /*Encode basicContainer */
	            ret = V2xFac_BasicContainerType_Encode((&(pVal->basicContainer)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode highFrequencyContainer */
	                ret = V2xFac_HighFrequencyContainerType_Encode((&(pVal->highFrequencyContainer)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode lowFrequencyContainer */
	                    if (pVal->exist.lowFrequencyContainer) {
	                    	ret = V2xFac_LowFrequencyContainerType_Encode((&(pVal->lowFrequencyContainer)), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode specialVehicleContainer */
	                        if (pVal->exist.specialVehicleContainer) {
	                        	ret = V2xFac_SpecialVehicleContainerType_Encode((&(pVal->specialVehicleContainer)), pBitStrm, pErrCode, FALSE);
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CamParametersType_Decode(V2xFac_CamParametersType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.lowFrequencyContainer = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CAMPARAMETERSTYPE;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.specialVehicleContainer = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_CAMPARAMETERSTYPE;
	    if (ret) {
	        /*Decode basicContainer */
	        ret = V2xFac_BasicContainerType_Decode((&(pVal->basicContainer)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode highFrequencyContainer */
	            ret = V2xFac_HighFrequencyContainerType_Decode((&(pVal->highFrequencyContainer)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode lowFrequencyContainer */
	                if (pVal->exist.lowFrequencyContainer) {
	                	ret = V2xFac_LowFrequencyContainerType_Decode((&(pVal->lowFrequencyContainer)), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode specialVehicleContainer */
	                    if (pVal->exist.specialVehicleContainer) {
	                    	ret = V2xFac_SpecialVehicleContainerType_Decode((&(pVal->specialVehicleContainer)), pBitStrm, pErrCode);
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && V2xFac_CamParametersType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_GenerationDeltaTime_Initialize(V2xFac_GenerationDeltaTime* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag V2xFac_GenerationDeltaTime_IsConstraintValid(const V2xFac_GenerationDeltaTime* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_V2XFAC_GENERATIONDELTATIME; 

	return ret;
}

flag V2xFac_GenerationDeltaTime_Encode(const V2xFac_GenerationDeltaTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_GenerationDeltaTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_GenerationDeltaTime_Decode(V2xFac_GenerationDeltaTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_V2XFAC_GENERATIONDELTATIME;

	return ret  && V2xFac_GenerationDeltaTime_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CoopAwarenessType_Initialize(V2xFac_CoopAwarenessType* pVal)
{
	(void)pVal;



	/*set generationDeltaTime */
	V2xFac_GenerationDeltaTime_Initialize((&(pVal->generationDeltaTime)));
	/*set camParameters */
	V2xFac_CamParametersType_Initialize((&(pVal->camParameters)));
}

flag V2xFac_CoopAwarenessType_IsConstraintValid(const V2xFac_CoopAwarenessType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_GenerationDeltaTime_IsConstraintValid((&(pVal->generationDeltaTime)), pErrCode);
    if (ret) {
        ret = V2xFac_CamParametersType_IsConstraintValid((&(pVal->camParameters)), pErrCode);
    }

	return ret;
}

flag V2xFac_CoopAwarenessType_Encode(const V2xFac_CoopAwarenessType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CoopAwarenessType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode generationDeltaTime */
	    ret = V2xFac_GenerationDeltaTime_Encode((&(pVal->generationDeltaTime)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode camParameters */
	        ret = V2xFac_CamParametersType_Encode((&(pVal->camParameters)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CoopAwarenessType_Decode(V2xFac_CoopAwarenessType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode generationDeltaTime */
	ret = V2xFac_GenerationDeltaTime_Decode((&(pVal->generationDeltaTime)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode camParameters */
	    ret = V2xFac_CamParametersType_Decode((&(pVal->camParameters)), pBitStrm, pErrCode);
	}

	return ret  && V2xFac_CoopAwarenessType_IsConstraintValid(pVal, pErrCode);
}



void V2xFac_CamMessageRootType_Initialize(V2xFac_CamMessageRootType* pVal)
{
	(void)pVal;



	/*set itsPduHeader */
	V2xFac_ItsPduHeaderType_Initialize((&(pVal->itsPduHeader)));
	/*set coopAwareness */
	V2xFac_CoopAwarenessType_Initialize((&(pVal->coopAwareness)));
}

flag V2xFac_CamMessageRootType_IsConstraintValid(const V2xFac_CamMessageRootType* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = V2xFac_ItsPduHeaderType_IsConstraintValid((&(pVal->itsPduHeader)), pErrCode);
    if (ret) {
        ret = V2xFac_CoopAwarenessType_IsConstraintValid((&(pVal->coopAwareness)), pErrCode);
    }

	return ret;
}

flag V2xFac_CamMessageRootType_Encode(const V2xFac_CamMessageRootType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? V2xFac_CamMessageRootType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode itsPduHeader */
	    ret = V2xFac_ItsPduHeaderType_Encode((&(pVal->itsPduHeader)), pBitStrm, pErrCode, FALSE);
	    // if (ret) {
	    //     /*Encode coopAwareness */
	    //     ret = V2xFac_CoopAwarenessType_Encode((&(pVal->coopAwareness)), pBitStrm, pErrCode, FALSE);
	    // }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag V2xFac_CamMessageRootType_Decode(V2xFac_CamMessageRootType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode itsPduHeader */
	ret = V2xFac_ItsPduHeaderType_Decode((&(pVal->itsPduHeader)), pBitStrm, pErrCode);
	// if (ret) {
	//     /*Decode coopAwareness */
	//     ret = V2xFac_CoopAwarenessType_Decode((&(pVal->coopAwareness)), pBitStrm, pErrCode);
	// }

	return ret  && V2xFac_CamMessageRootType_IsConstraintValid(pVal, pErrCode);
}

